<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Atomes Clicker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --fg:#ffffff;
      --bg:#0b0b0f;
      --card:rgba(255,255,255,.10);
      --pill:rgba(255,255,255,.18);
      --accent:rgba(255,255,255,.85);
      --grid-max:clamp(760px,88vw,1200px);
    }
    /* Thèmes */
    body.theme-dark{ --fg:#f5f7ff; --bg:#0b0b0f; --card:rgba(255,255,255,.10); --pill:rgba(255,255,255,.18); --accent:rgba(255,255,255,.85); }
    body.theme-light{ --fg:#0b0b0f; --bg:#f6f8ff; --card:rgba(0,0,0,.06); --pill:rgba(0,0,0,.12); --accent:rgba(12,16,32,.85); }
    body.theme-rainbow{ --fg:#ffffff; --accent:rgba(255,255,255,.85); }
    html, body {
      margin:0; padding:0; width:100%; height:100%; min-height:100dvh;
      font-family:'Orbitron',sans-serif; color:var(--fg);
      overflow-x:hidden; overflow-y:auto; user-select:none;
    }
    body { background: var(--bg); transition: background .4s ease, color .4s ease; min-height:100dvh; display:flex; flex-direction:column; }
    /* Arc-en-ciel animé uniquement pour le thème rainbow */
    body.theme-rainbow{ background: linear-gradient(270deg, red, orange, yellow, green, blue, indigo, violet); background-size:1400% 1400%; animation: rainbow 20s linear infinite; }
    @keyframes rainbow { 0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%} }

    .page { display:none; width:100%; height:100%; box-sizing:border-box; position:relative; padding:clamp(1.2rem, 5vh, 3rem) clamp(1rem, 3.5vw, 3rem); overflow:auto; }
    .page.active { display:flex; flex-direction:column; align-items:center; gap:clamp(1rem, 2.6vh, 2rem); justify-content:flex-start; flex:1; }

    /* Boutons navigation / barre du haut */
    .app-header {
      position:sticky;
      top:0;
      z-index:150;
      background:var(--bg);
      box-shadow:0 6px 18px rgba(0,0,0,.22);
      backdrop-filter:blur(12px);
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .nav-menu {
      display:flex;
      align-items:center;
      justify-content:center;
      gap:clamp(.35rem, .8vw, .7rem);
      padding:clamp(.45rem, 1.3vh, .75rem) clamp(1rem, 3vw, 2rem);
      margin:0 auto;
      width:100%;
      list-style:none;
      flex-wrap:nowrap;
      overflow-x:auto;
      scrollbar-width:none;
      -webkit-overflow-scrolling:touch;
    }
    .nav-menu::-webkit-scrollbar { display:none; }
    .nav-button {
      display:flex;
      align-items:center;
      justify-content:center;
      flex:0 0 auto;
      min-height:clamp(2rem, 5vh, 2.6rem);
      padding:clamp(.35rem, 1vh, .6rem) clamp(.75rem, 1.8vw, 1.2rem);
      border:none;
      border-radius:999px;
      background:var(--pill);
      color:var(--fg);
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.58rem, .95vw, .78rem);
      font-weight:600;
      letter-spacing:.12em;
      text-transform:uppercase;
      cursor:pointer;
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease, color .2s ease;
      white-space:nowrap;
    }
    .nav-button[disabled]{
      opacity:.4;
      cursor:not-allowed;
      pointer-events:none;
    }
    .nav-button .nav-label {
      line-height:1;
    }
    .nav-button:hover,
    .nav-button:focus-visible {
      transform:translateY(-1px);
      box-shadow:0 10px 22px rgba(0,0,0,.26);
    }
    .nav-button.active {
      background:var(--accent);
      color:var(--bg);
      box-shadow:0 12px 24px rgba(0,0,0,.28);
    }
    main {
      flex:1;
      display:flex;
      flex-direction:column;
    }
    #pageContainer {
      flex:1;
      display:flex;
      flex-direction:column;
      position:relative;
    }
    .sr-only {
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
    .placeholder-card {
      width:min(100%, var(--grid-max));
      margin:0 auto;
      background:var(--card);
      border-radius:18px;
      padding:clamp(1.2rem, 3vh, 2rem) clamp(1.2rem, 4vw, 2.2rem);
      box-shadow:0 14px 28px rgba(0,0,0,.28);
      display:flex;
      flex-direction:column;
      gap:.75rem;
    }

    .revive-wrap{
      width:min(100%, var(--grid-max));
      margin:0 auto;
    }
    .revive-card{
      display:flex;
      flex-direction:column;
      gap:clamp(.85rem, 2vh, 1.2rem);
    }
    .revive-heading{
      margin:0;
      font-size:clamp(1.2rem, 2.6vw, 1.8rem);
      letter-spacing:.12em;
      text-transform:uppercase;
    }
    .revive-intro{
      margin:0;
      font-size:clamp(.85rem, 1.3vw, 1.05rem);
      opacity:.8;
    }
    .revive-stats{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(180px, 1fr));
      gap:clamp(.6rem, 1.8vh, 1rem);
    }
    .revive-stat{
      background:var(--card);
      border-radius:14px;
      padding:clamp(.6rem, 1.6vh, .9rem) clamp(.9rem, 2vw, 1.2rem);
      display:flex;
      flex-direction:column;
      gap:.35rem;
    }
    .revive-stat span{
      text-transform:uppercase;
      letter-spacing:.14em;
      font-size:clamp(.65rem, .9vw, .8rem);
      opacity:.65;
    }
    .revive-stat strong{
      font-size:clamp(1rem, 1.8vw, 1.4rem);
    }
    .revive-offer{
      display:flex;
      flex-wrap:wrap;
      gap:clamp(.8rem, 2vh, 1.2rem);
      justify-content:space-between;
      align-items:center;
      padding:clamp(.9rem, 2vh, 1.3rem);
      border-radius:14px;
      background:var(--pill);
    }
    .revive-offer-details{
      display:flex;
      flex-direction:column;
      gap:.45rem;
    }
    .revive-offer-line{
      display:flex;
      justify-content:space-between;
      gap:1.2rem;
      font-size:clamp(.85rem, 1.3vw, 1.05rem);
    }
    .revive-offer-line span{
      text-transform:uppercase;
      letter-spacing:.12em;
      opacity:.7;
    }
    .revive-offer button{
      padding:clamp(.6rem, 1.8vh, 1rem) clamp(1.2rem, 3vw, 2rem);
      border:none;
      border-radius:999px;
      background:linear-gradient(135deg, rgba(120,220,255,.4), rgba(60,120,255,.75));
      color:#fff;
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.85rem, 1.3vw, 1.1rem);
      letter-spacing:.14em;
      text-transform:uppercase;
      cursor:pointer;
      transition:transform .2s ease, box-shadow .2s ease, opacity .2s ease;
      white-space:nowrap;
    }
    .revive-offer button:disabled{
      opacity:.5;
      cursor:not-allowed;
      box-shadow:none;
    }
    .revive-offer button:not(:disabled):hover{
      transform:translateY(-1px);
      box-shadow:0 10px 24px rgba(0,0,0,.28);
    }
    .revive-locked{
      margin:0;
      font-size:clamp(.8rem, 1.2vw, .95rem);
      opacity:.75;
      text-align:center;
    }
    .revive-note{
      margin:0;
      font-size:clamp(.78rem, 1.15vw, .95rem);
      opacity:.75;
    }
    .placeholder-card h2 {
      margin:0;
      font-size:clamp(1.1rem, 2.4vw, 1.6rem);
      letter-spacing:.08em;
    }
    .placeholder-card p {
      margin:0;
      font-size:clamp(.85rem, 1.3vw, 1.05rem);
      opacity:.8;
    }

    .info-grid {
      width:min(100%, var(--grid-max));
      margin:0 auto;
      display:grid;
      gap:clamp(.9rem, 2.4vh, 1.6rem);
    }
    .info-card {
      background:var(--card);
      border-radius:18px;
      padding:clamp(1rem, 2.4vh, 1.6rem) clamp(1.2rem, 3vw, 2.1rem);
      box-shadow:0 12px 26px rgba(0,0,0,.24);
      display:flex;
      flex-direction:column;
      gap:clamp(.6rem, 1.6vh, 1rem);
    }
    .info-card h2 {
      margin:0;
      font-size:clamp(.85rem, 1.3vw, 1.05rem);
      letter-spacing:.18em;
      text-transform:uppercase;
      opacity:.85;
    }
    .info-metrics {
      display:flex;
      flex-direction:column;
      gap:clamp(.5rem, 1.4vh, .85rem);
    }
    .info-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:clamp(.75rem, 2vw, 1.2rem);
      font-size:clamp(.78rem, 1.1vw, .95rem);
      flex-wrap:wrap;
    }
    .info-row span {
      text-transform:uppercase;
      letter-spacing:.14em;
      opacity:.7;
      flex:1 1 auto;
    }
    .info-row strong {
      font-size:clamp(.95rem, 1.6vw, 1.3rem);
      font-weight:700;
      letter-spacing:.08em;
      margin-left:auto;
      text-align:right;
    }
    .info-row.total {
      border-top:1px solid rgba(255,255,255,.12);
      padding-top:clamp(.45rem, 1.2vh, .75rem);
      margin-top:clamp(.45rem, 1.2vh, .75rem);
    }
    .info-row-multi {
      align-items:flex-start;
    }
    .info-row-multi span {
      padding-top:.2rem;
    }
    .multiplier-list {
      list-style:none;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:.35rem;
      flex:1;
    }
    .multiplier-item {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:.75rem;
      font-size:clamp(.75rem, 1.05vw, .9rem);
    }
    .multiplier-item span {
      text-transform:uppercase;
      letter-spacing:.12em;
      opacity:.68;
    }
    .multiplier-item strong {
      font-size:clamp(.9rem, 1.4vw, 1.1rem);
      letter-spacing:.08em;
    }

    /* Sélecteur de thème (boutons shop) */
    .theme-selector {
      display:flex;
      align-items:center;
      gap:clamp(.55rem, 1.5vw, 1rem);
      background:var(--pill);
      padding:clamp(.45rem, 1.3vh, .85rem) clamp(.65rem, 1.9vw, 1.3rem);
      border-radius:12px;
      box-shadow:0 6px 16px rgba(0,0,0,.18);
    }
    .theme-label {
      font-size:clamp(.65rem,1vw,.9rem);
      text-transform:uppercase;
      letter-spacing:.18em;
      opacity:.75;
    }
    #themeControls {
      display:flex;
      align-items:center;
      gap:clamp(.4rem, 1vw, .7rem);
    }
    #themeControls button { width:clamp(2.4rem, 4vw, 3.3rem); height:clamp(2.4rem, 4vw, 3.3rem); border-radius:12px; border:none; cursor:pointer; box-shadow:0 6px 16px rgba(0,0,0,.22); transition:transform .2s ease, box-shadow .2s ease; }
    #themeControls button:hover { transform:translateY(-2px); box-shadow:0 10px 20px rgba(0,0,0,.28); }
    #themeControls button.active { box-shadow:0 0 0 4px var(--accent), 0 6px 16px rgba(0,0,0,.22); }
    #themeControls button[data-theme="light"] { background:#ffffff; }
    #themeControls button[data-theme="dark"] { background:#0b0b0f; }
    #themeControls button[data-theme="rainbow"] { background:linear-gradient(135deg, red, orange, yellow, green, cyan, blue, violet); }

    /* Compteurs */
    .atomsCluster {
      display:grid;
      grid-template-columns:minmax(0, 1fr) minmax(0, 1.8fr) minmax(0, 1fr);
      grid-template-areas:"apc atoms aps";
      gap:clamp(.35rem, 1.6vw, 1.2rem);
      width:100%;
      margin:clamp(.4rem, 2.4vh, 1.4rem) 0 0;
      align-self:stretch;
      align-items:stretch;
      justify-items:stretch;
    }
    .atomsCluster > * {
      min-width:0;
    }
    .atomsBox {
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:.3rem;
      font-size:clamp(.85rem, 2.4vw, 2.2rem);
      padding:clamp(.5rem, 1.8vw, 1.3rem) clamp(.8rem, 2.8vw, 2.3rem);
      background:var(--card);
      border-radius:14px;
      box-shadow:0 8px 20px rgba(0,0,0,.2);
      width:100%;
      max-width:none;
      justify-self:stretch;
      box-sizing:border-box;
      grid-area:atoms;
    }
    .atomsLabel {
      font-size:clamp(.5rem, .95vw, .88rem);
      text-transform:uppercase;
      letter-spacing:.14em;
      opacity:.78;
    }
    .atomsValue {
      font-weight:700;
      line-height:1.1;
      font-size:clamp(1.1rem, 4.5vw, 3.2rem);
    }
    .statPill {
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      background:var(--pill);
      padding:clamp(.4rem, 1.4vw, .95rem) clamp(.55rem, 1.8vw, 1.2rem);
      border-radius:12px;
      box-shadow:0 6px 16px rgba(0,0,0,.18);
      gap:.2rem;
      min-height:100%;
      box-sizing:border-box;
    }
    .statLabel {
      font-size:clamp(.48rem,.95vw,.85rem);
      text-transform:uppercase;
      letter-spacing:.18em;
      opacity:.7;
    }
    .statValue {
      font-size:clamp(.65rem, 2.1vw, 1.45rem);
      font-weight:700;
      line-height:1.1;
    }
    .statPill-apc {
      background:linear-gradient(140deg, rgba(255,140,82,.25), rgba(255,200,160,.18));
      grid-area:apc;
    }
    .statPill-aps {
      background:linear-gradient(140deg, rgba(0,210,255,.25), rgba(120,255,220,.18));
      grid-area:aps;
    }

    /* Icône atome */
    .atom { width:clamp(9rem,22vmin,18rem); aspect-ratio:1; pointer-events:none; transition:transform .18s ease, filter .18s ease; transform-origin:center; }
    .atom.colorShift { filter:drop-shadow(0 0 18px rgba(255,213,79,.55)) drop-shadow(0 0 32px rgba(255,213,79,.35)); }
    .atom.enflé { transform:scale(1.22); }
    .atom.enflé.crit { transform:scale(1.32); }
    .atom.crit {
      filter:drop-shadow(0 0 20px rgba(255,255,210,.9)) drop-shadow(0 0 42px rgba(255,220,150,.8)) drop-shadow(0 0 70px rgba(255,190,120,.6));
      animation:critSpark .55s ease-out;
    }
    .nucleus { fill:var(--fg); transition:fill .2s ease, filter .2s ease; }
    .nucleus.colorShift { fill:#ffd54f; }
    .atom.crit .nucleus { fill:#ffffff; filter:drop-shadow(0 0 18px rgba(255,255,255,.85)); }
    .orbit { fill:none; stroke:var(--fg); stroke-width:2; opacity:.9; transition:stroke .2s ease, opacity .2s ease; }
    .atom.crit .orbit { stroke:rgba(255,244,214,.95); opacity:1; filter:drop-shadow(0 0 14px rgba(255,240,200,.65)); }
    @keyframes critSpark {
      0% { filter:drop-shadow(0 0 8px rgba(255,255,255,.8)) drop-shadow(0 0 18px rgba(255,220,150,.75)); }
      40% { filter:drop-shadow(0 0 26px rgba(255,255,200,1)) drop-shadow(0 0 52px rgba(255,200,140,.85)); }
      100% { filter:drop-shadow(0 0 14px rgba(255,240,210,.75)) drop-shadow(0 0 30px rgba(255,200,140,.65)); }
    }
    #confettiLayer {
      position:fixed;
      inset:0;
      pointer-events:none;
      overflow:hidden;
      z-index:998;
    }
    .confetti-piece {
      position:absolute;
      display:block;
      will-change:transform, opacity;
      opacity:0;
      filter:drop-shadow(0 0 6px rgba(0,0,0,.2));
    }

    .frenzyOrb {
      position:absolute;
      width:clamp(9rem, 22vmin, 18rem);
      aspect-ratio:1;
      border:none;
      padding:0;
      background:transparent center/contain no-repeat;
      box-shadow:0 10px 26px rgba(0,0,0,.28);
      pointer-events:none;
      opacity:0;
      transform:translate(-50%, -50%) scale(.7);
      transition:opacity .25s ease, transform .25s ease;
      z-index:200;
      cursor:pointer;
    }
    .frenzyOrb:focus-visible {
      outline:3px solid var(--accent);
      outline-offset:6px;
    }
    .frenzyOrb.visible {
      opacity:1;
      pointer-events:auto;
      transform:translate(-50%, -50%) scale(1);
    }
    .frenzyOrb:disabled {
      cursor:default;
    }
    #frenzyOrb {
      background-image:url("Assets/Image/frenesieAPC.png");
    }
    #apsFrenzyOrb {
      background-image:url("Assets/Image/frenesieAPS.png");
    }

    .frenzyStatus {
      font-size:clamp(.55rem, .95vw, .8rem);
      opacity:.8;
      margin-top:.2rem;
      letter-spacing:.05em;
    }
    .frenzyStatus:empty { display:none; }
    .frenzyStatus.active {
      opacity:1;
      color:var(--accent);
    }

    .auto-gacha-panel {
      position:fixed;
      left:50%;
      bottom:clamp(1rem, 3vh, 2.4rem);
      transform:translateX(-50%);
      background:var(--card);
      border-radius:14px;
      box-shadow:0 14px 26px rgba(0,0,0,.32);
      padding:clamp(.65rem, 1.5vh, 1rem) clamp(.9rem, 2vw, 1.4rem);
      display:flex;
      flex-direction:column;
      gap:.4rem;
      z-index:120;
      min-width:clamp(12rem, 42vw, 20rem);
      border:1px solid rgba(255,255,255,.16);
    }
    .auto-gacha-panel.hidden {
      display:none;
    }
    .auto-gacha-header {
      font-size:clamp(.75rem,1.2vw,.95rem);
      letter-spacing:.12em;
      text-transform:uppercase;
      opacity:.8;
    }
    .auto-gacha-content {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:clamp(.6rem, 1.8vw, 1.2rem);
    }
    .auto-gacha-name {
      font-size:clamp(.95rem, 1.8vw, 1.2rem);
      font-weight:700;
    }
    .auto-gacha-result {
      font-size:clamp(.95rem, 1.6vw, 1.15rem);
      text-align:right;
    }

    /* SHOP */
    .shop-wrap {
      width:100%;
      display:flex;
      justify-content:center;
    }
    .card {
      background: var(--card);
      border-radius:12px;
      box-sizing:border-box;
      padding:clamp(1rem, 2.5vh, 1.5rem);
      width:100%;
    }
    .shop-grid {
      width:min(100%, var(--grid-max));
      display:grid;
      gap:clamp(.9rem, 2vw, 1.6rem);
      grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));
    }
    .shop-card {
      display:flex;
      flex-direction:column;
      gap:clamp(.75rem, 2vh, 1.2rem);
      padding:clamp(.9rem, 2.2vh, 1.4rem) clamp(1rem, 2.8vw, 1.8rem);
      box-shadow:0 10px 22px rgba(0,0,0,.22);
    }
    .shop-card-title {
      margin:0;
      font-size:clamp(.95rem, 1.6vw, 1.25rem);
      text-transform:uppercase;
      letter-spacing:.12em;
    }
    .shop-upgrade {
      display:flex;
      flex-direction:column;
      gap:.45rem;
    }
    .shop-upgrade-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:.6rem;
    }
    .shop-upgrade-label {
      font-size:clamp(.72rem, 1.1vw, .95rem);
      text-transform:uppercase;
      letter-spacing:.16em;
    }
    .shop-upgrade-meta {
      font-size:clamp(.6rem, .95vw, .8rem);
      opacity:.7;
    }
    .shop-options {
      display:flex;
      gap:clamp(.4rem, 1.2vw, .85rem);
      flex-wrap:wrap;
    }
    .shop-option {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      border:none;
      border-radius:12px;
      padding:clamp(.45rem, 1.1vw, .75rem) clamp(.6rem, 1.8vw, 1rem);
      min-width:clamp(3.8rem, 12vw, 5.1rem);
      background:var(--pill);
      color:var(--fg);
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.6rem, .95vw, .82rem);
      font-weight:600;
      letter-spacing:.12em;
      text-transform:uppercase;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.18);
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease, color .2s ease;
      gap:.2rem;
    }
    .shop-option:hover,
    .shop-option:focus-visible {
      transform:translateY(-1px);
      box-shadow:0 10px 22px rgba(0,0,0,.24);
    }
    .shop-option .option-tier {
      font-size:clamp(.8rem, 1.4vw, 1.05rem);
      font-weight:700;
    }
    .shop-option .option-price {
      font-size:clamp(.52rem, .85vw, .72rem);
      opacity:.8;
      line-height:1.1;
    }
    .shop-option.not-available {
      background:rgba(255,255,255,.12);
      color:rgba(255,255,255,.55);
      box-shadow:none;
    }
    body.theme-light .shop-option.not-available {
      background:rgba(0,0,0,.08);
      color:rgba(0,0,0,.5);
    }
    .shop-option:disabled {
      cursor:not-allowed;
      opacity:.75;
      transform:none;
    }
    .shop-upgrade-single .shop-option {
      width:100%;
      flex-direction:row;
      justify-content:space-between;
      align-items:center;
    }
    .shop-upgrade-single .option-tier {
      font-size:clamp(.85rem, 1.5vw, 1.1rem);
    }
    .shop-card.gacha-card .shop-options {
      justify-content:space-between;
    }

    /* OPTIONS */
    .options-wrap {
      width:min(100%, var(--grid-max));
      margin:0 auto;
      display:grid;
      gap:clamp(.9rem, 2vw, 1.6rem);
      grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));
    }
    .options-card {
      display:flex;
      flex-direction:column;
      gap:clamp(.6rem, 2vh, 1rem);
      box-shadow:0 8px 20px rgba(0,0,0,.18);
    }
    .options-title {
      margin:0;
      font-size:clamp(1rem, 2vw, 1.35rem);
      text-transform:uppercase;
      letter-spacing:.14em;
    }
    .options-text {
      margin:0;
      font-size:clamp(.75rem, 1.1vw, .95rem);
      opacity:.8;
    }
    .options-reset {
      align-self:flex-start;
      padding:clamp(.55rem, 1.4vw, .9rem) clamp(1rem, 2.4vw, 1.6rem);
      border:none;
      border-radius:10px;
      background:linear-gradient(135deg, rgba(255,90,90,.35), rgba(190,0,0,.55));
      color:#fff;
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.75rem, 1vw, .95rem);
      letter-spacing:.14em;
      text-transform:uppercase;
      cursor:pointer;
      box-shadow:0 8px 20px rgba(0,0,0,.22);
      transition:transform .2s ease, box-shadow .2s ease, filter .2s ease;
    }
    .options-reset:hover,
    .options-reset:focus-visible {
      transform:translateY(-1px);
      box-shadow:0 10px 24px rgba(0,0,0,.28);
      filter:brightness(1.05);
    }

    /* Loot encart */
    .loot {
      margin-top:clamp(.6rem, 2vh, 1rem);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:clamp(.6rem, 2vw, 1.2rem);
      flex-wrap:wrap;
      background:var(--pill);
      padding:clamp(.55rem,1.2vw,.95rem) clamp(.75rem,2vw,1.3rem);
      border-radius:12px;
      box-shadow:0 6px 16px rgba(0,0,0,.18);
    }
    .loot.hidden { display:none; }
    .loot-detail { display:flex; flex-direction:column; gap:.2rem; }
    .loot-name { font-size:clamp(.9rem,1.4vw,1.1rem); font-weight:700; }
    .loot-family { font-size:clamp(.7rem,1.1vw,.9rem); opacity:.75; }
    .loot-result {
      display:inline-block;
      position:relative;
      overflow:hidden;
      font-size:clamp(.95rem,1.6vw,1.2rem);
      font-weight:700;
      margin-left:auto;
      text-align:right;
    }
    .loot-result.is-new {
      color:#ffffff;
      text-shadow:0 0 12px rgba(255,255,255,.85), 0 0 24px rgba(160,220,255,.75);
    }
    .loot-result.is-new::after {
      content:"";
      position:absolute;
      top:0; bottom:0; left:-70%; right:-70%;
      background:linear-gradient(120deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.9) 45%, rgba(255,255,255,0) 60%);
      transform:skewX(-15deg);
      animation:lootShine 1.8s ease-in-out infinite;
      opacity:.7;
    }
    .loot-result.rarity-common { color:#34d058; }
    .loot-result.rarity-uncommon { color:#1a8f52; }
    .loot-result.rarity-rare { color:#4ea1ff; }
    .loot-result.rarity-epic { color:#bb7bff; }
    .loot-result.rarity-legendary { color:#ffa54b; }
    .loot-result.rarity-mythic {
      background:linear-gradient(90deg, red, orange, yellow, green, cyan, blue, violet, red);
      background-size:300% 100%;
      -webkit-background-clip:text;
      color:transparent;
      animation:lootRainbow 3s linear infinite;
      text-shadow:0 0 18px rgba(255,255,255,.35);
    }
    @keyframes lootRainbow {
      0% { background-position:0% 50%; }
      100% { background-position:100% 50%; }
    }
    @keyframes lootShine {
      0% { transform:translateX(-80%) skewX(-15deg); }
      100% { transform:translateX(120%) skewX(-15deg); }
    }

    /* GACHA PAGE */
    .gacha-wrap { width:min(100%,var(--grid-max,1200px)); margin:0 auto; box-sizing:border-box; display:flex; flex-direction:column; gap:clamp(1rem,3vh,2rem); align-items:center; justify-content:flex-start; flex:1; }

    .gacha-info {
      background:var(--card); border-radius:12px; padding:clamp(.6rem,1.5vh,.95rem);
      display:flex; flex-direction:column; gap:clamp(.45rem,1.1vh,.8rem);
      align-items:stretch; align-self:stretch;
      min-height:clamp(48px,3.4vw,56px); box-shadow:0 12px 24px rgba(0,0,0,.18);
      grid-column:3 / 13; grid-row:1 / 4;
      width:100%; height:100%; box-sizing:border-box;
    }
    .gacha-info .info-title {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:.75rem;
      background:var(--pill); border-radius:12px; padding:.35rem .85rem;
      font-size:clamp(.72rem,1vw,.9rem);
    }
    .gacha-info .info-title .iso-count {
      font-size:clamp(.68rem,.95vw,.85rem);
      opacity:.85;
    }
    .gacha-info .info-lines {
      display:flex;
      flex-direction:column;
      width:100%;
      gap:clamp(.35rem,1vw,.6rem);
    }
    .gacha-info .info-line {
      background:var(--pill); border-radius:999px; padding:.28rem .7rem;
      font-size:clamp(.66rem,.9vw,.85rem); opacity:.95; text-align:left;
    }
    .awaken-box {
      background:var(--card);
      border-radius:12px;
      padding:clamp(.45rem,1.2vh,.75rem);
      display:flex;
      align-items:center;
      justify-content:center;
      grid-column:13 / 18;
      grid-row:1 / 2;
      min-height:clamp(48px,3.4vw,56px);
      box-shadow:0 12px 24px rgba(0,0,0,.18);
      width:100%;
      box-sizing:border-box;
    }
    .awaken-box .awaken-btn {
      width:100%;
      max-width:clamp(11rem, 26vw, 18rem);
      text-align:center;
    }
    @media (max-width: 900px) {
      .awaken-box {
        grid-column:1 / -1;
        grid-row:auto;
      }
    }
    .awaken-btn {
      padding:clamp(.45rem,1.1vh,.7rem) clamp(.7rem,1.6vw,1rem);
      border:none;
      border-radius:12px;
      background:linear-gradient(135deg, rgba(0,255,255,.35), rgba(0,160,255,.55));
      color:var(--fg);
      font-size:clamp(.72rem,1.05vw,.9rem);
      font-weight:600;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
      transition:transform .15s ease, box-shadow .2s ease, filter .2s ease;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:.35rem;
    }
    .awaken-btn:hover:not(:disabled) {
      transform:translateY(-1px);
      box-shadow:0 10px 22px rgba(0,0,0,.3);
    }
    .awaken-btn:disabled {
      cursor:not-allowed;
      opacity:.55;
      filter:grayscale(.2);
      box-shadow:none;
    }

    .gacha-grid {
      --cell-size: clamp(36px, min(4vw, 6vh), 60px);
      margin:0 auto;
      width:min(100%,var(--grid-max,1100px));
      max-width:var(--grid-max,1100px);
      display:grid;
      grid-template-columns: repeat(18, minmax(0, 1fr));
      grid-auto-rows:var(--cell-size);
      gap:clamp(.08rem, min(.35vw, .8vh), .25rem);
      position:relative;
    }
    .cell {
      background:var(--bg-base, var(--card)); border:1px solid rgba(255,255,255,.12); border-radius:10px;
      padding:clamp(.2rem, min(.45vw, .8vh), .32rem) clamp(.18rem, min(.42vw, .75vh), .3rem);
      text-align:center; cursor:pointer;
      display:flex; flex-direction:column; align-items:center; justify-content:center; transition:background .3s ease, transform .2s ease, border-color .3s ease;
      color:#0b0b0f; min-height:var(--cell-size);
      position:relative; overflow:hidden;
    }
    .cell:hover { transform:translateY(-2px); }
    @keyframes awakenSpin {
      from { transform:rotate(0deg); }
      to { transform:rotate(360deg); }
    }
    .cell.awaken-ready {
      box-shadow:0 0 18px rgba(255,255,255,.45), 0 0 32px rgba(0,200,255,.25);
    }
    .cell.awaken-ready::after {
      content:"";
      position:absolute;
      inset:-3px;
      border-radius:inherit;
      background:conic-gradient(from 0deg, rgba(255,255,255,.05) 0deg, rgba(0,255,255,.55) 120deg, rgba(255,255,255,.05) 240deg, rgba(0,255,120,.55) 360deg);
      animation:awakenSpin 2.4s linear infinite;
      pointer-events:none;
      -webkit-mask:radial-gradient(farthest-side, transparent calc(100% - 3px), #000 calc(100% - 2px));
      mask:radial-gradient(farthest-side, transparent calc(100% - 3px), #000 calc(100% - 2px));
      opacity:.85;
    }
    .cell .Z { font-size:clamp(.5rem, min(.95vw, 1.8vh), .75rem); opacity:.75; }
    .cell .sym { font-size:clamp(.75rem, min(1.35vw, 2.7vh), 1.1rem); font-weight:700; }
    .cell.owned { background:var(--bg-owned, var(--card)); border-color:rgba(255,255,255,.28); }
    body.theme-light .cell { border-color:rgba(0,0,0,.08); }
    body.theme-light .cell.owned { border-color:rgba(0,0,0,.18); }

    .hidden { display:none; }

    /* Layout spécifiques par page */
    #mainPage.page.active { justify-content:flex-start; }
    #mainPage .atomsCluster { order:1; margin-bottom:clamp(1.2rem, 4vh, 3rem); }
    #mainPage .atom { order:2; margin:0 auto; }

    #shopPage { padding-left:clamp(1rem, 3vw, 2.2rem); padding-right:clamp(1rem, 3vw, 2.2rem); }
    #shopPage .atomsCluster { order:1; }
    #shopPage .shop-wrap { order:2; margin:clamp(.6rem, 2vh, 1.2rem) auto; }

    #gachaPage.page.active { justify-content:flex-start; }
    #gachaPage .gacha-wrap {
      order:2;
      flex:1;
      width:100%;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:clamp(.6rem, min(2vh, 2vw), 1.4rem);
      padding-top:clamp(1rem, 4vh, 2.5rem);
    }

    .loot-detail { flex:1; }

    /* BONUS PAGE */
    #bonusPage.page.active { justify-content:flex-start; }
    #bonusPage .bonus-wrap {
      order:2;
      width:min(100%, 720px);
      display:flex;
      flex-direction:column;
      gap:clamp(.6rem, 1.6vh, 1rem);
      background:var(--card);
      padding:clamp(.85rem, 2.2vh, 1.3rem) clamp(1rem, 2.6vw, 1.6rem);
      border-radius:16px;
      box-shadow:0 10px 22px rgba(0,0,0,.18);
    }
    #bonusPage .bonus-title {
      margin:0;
      font-size:clamp(1rem, 2vw, 1.4rem);
      text-transform:uppercase;
      letter-spacing:.16em;
    }
    #bonusList ul {
      margin:0;
      padding-left:1.25rem;
      display:flex;
      flex-direction:column;
      gap:.45rem;
    }
    #bonusList li { line-height:1.4; }
    #bonusList p { margin:0; }
    #bonusList .bonus-section {
      display:flex;
      flex-direction:column;
      gap:clamp(.45rem, 1.3vh, .75rem);
    }
    #bonusList .bonus-section + .bonus-section {
      margin-top:clamp(.8rem, 2vh, 1.2rem);
    }
    #bonusList .bonus-section-trophies {
      width:100%;
    }
    .trophy-list {
      list-style:none;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:clamp(.5rem,1.3vh,.8rem);
    }
    .trophy-list li {
      background:var(--pill);
      border-radius:12px;
      padding:clamp(.45rem,1.2vh,.75rem) clamp(.6rem,1.6vw,1.1rem);
      display:flex;
      flex-direction:column;
      gap:.3rem;
      border:1px solid transparent;
      box-shadow:0 8px 18px rgba(0,0,0,.16);
    }
    .trophy-list li.trophy-unlocked {
      border-color:rgba(255,255,255,.35);
      box-shadow:0 12px 28px rgba(0,0,0,.25);
    }
    .trophy-list li.trophy-locked {
      opacity:.9;
    }
    .trophy-name {
      font-weight:700;
      font-size:clamp(.85rem,1.4vw,1.05rem);
    }
    .trophy-desc {
      font-size:clamp(.68rem,1vw,.85rem);
      opacity:.82;
    }
    .trophy-progress {
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:clamp(.6rem,.9vw,.75rem);
      opacity:.78;
      gap:.5rem;
    }
    .trophy-progress-value {
      font-weight:600;
    }
    .trophy-progress-target {
      opacity:.75;
      text-align:right;
    }
    .bonus-subtitle {
      margin:0;
      font-size:clamp(.85rem, 1.8vw, 1.1rem);
      text-transform:uppercase;
      letter-spacing:.12em;
      opacity:.85;
    }
    .set-status-grid {
      display:flex;
      flex-direction:column;
      gap:clamp(.35rem, 1.2vh, .65rem);
    }
    .set-status-card {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:clamp(.45rem, 1.2vw, .85rem);
      padding:clamp(.55rem, 1.4vh, .9rem) clamp(.75rem, 2vw, 1.25rem);
      border-radius:12px;
      background:var(--pill);
      box-shadow:0 6px 16px rgba(0,0,0,.14);
    }
    .set-status-card.set-complete {
      box-shadow:0 0 0 2px rgba(120,255,200,.35), 0 6px 16px rgba(0,0,0,.16);
    }
    .set-status-name {
      font-weight:600;
      letter-spacing:.05em;
    }
    .set-status-info {
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:.2rem;
      font-size:clamp(.7rem, 1.3vw, .95rem);
    }
    .set-status-progress {
      opacity:.75;
    }
    .set-status-state {
      font-weight:700;
    }
    .set-status-card.set-complete .set-status-state {
      color:var(--accent);
    }
    .set-status-card.set-incomplete .set-status-state {
      opacity:.7;
    }

    @media (min-width: 960px) {
      .info-grid { grid-template-columns:repeat(2, minmax(0, 1fr)); }
    }

    @media (max-width: 900px) {
      .page { padding:clamp(1.25rem,5vh,2.5rem) clamp(1rem,5vw,2rem); }
      .nav-menu { justify-content:flex-start; }
      .nav-button { flex:0 0 auto; }
      .theme-selector {
        width:100%;
        flex-direction:column;
        align-items:flex-start;
        gap:clamp(.45rem,2vh,.9rem);
      }
      #themeControls {
        width:100%;
        justify-content:flex-start;
        flex-wrap:wrap;
        gap:clamp(.45rem,3vw,.85rem);
      }
      #themeControls button { width:clamp(2.4rem,10vw,3rem); height:clamp(2.4rem,10vw,3rem); }
      .atomsCluster {
        grid-template-columns:minmax(0, 1fr) minmax(0, 1.5fr) minmax(0, 1fr);
        gap:clamp(.3rem, 2.4vw, .9rem);
      }
      .atomsBox {
        font-size:clamp(.7rem, 4.6vw, 1.9rem);
        padding:clamp(.45rem, 3vw, 1rem) clamp(.6rem, 5vw, 1.6rem);
      }
      .statPill {
        padding:clamp(.35rem, 2.6vw, .85rem) clamp(.45rem, 4vw, 1.1rem);
      }
      .statLabel { letter-spacing:.12em; }
      .statValue { font-size:clamp(.6rem,4.8vw,1.4rem); }
      #shopPage { padding-left:clamp(.75rem,4vw,1.4rem); padding-right:clamp(.75rem,4vw,1.4rem); }
      .shop-grid { grid-template-columns:1fr; }
      .shop-card { gap:clamp(.6rem, 2vh, 1rem); }
      .shop-options { justify-content:flex-start; }
      .shop-option { min-width:clamp(3.4rem, 28vw, 4.8rem); }
      .gacha-wrap { gap:clamp(1rem,4vh,1.8rem); }
      .gacha-grid { width:100%; max-width:100%; }
    }

    @media (max-width: 720px) {
      .nav-menu { justify-content:flex-start; }
      .nav-button { min-width:clamp(4.2rem, 26vw, 6rem); }
      .gacha-info .info-lines { grid-template-columns:1fr; }
    }

    @media (max-height: 720px) {
      .atom { width:clamp(7.5rem,20vmin,15rem); }
      .gacha-grid { --cell-size: clamp(32px, min(3.6vw, 5.5vh), 48px); }
      .gacha-info { min-height:clamp(32px, min(3.6vw, 5.5vh), 48px); }
    }

    .modal-overlay {
      position:fixed; inset:0; background:rgba(0,0,0,.6);
      display:flex; align-items:center; justify-content:center;
      z-index:1000; padding:1.5rem;
    }


    .modal-overlay.hidden {
      display:none;
    }


    .modal-content {
      background:var(--card); color:var(--fg); border-radius:16px;
      padding:clamp(1rem,2.5vh,1.6rem) clamp(1.2rem,3vw,2rem);
      width:min(100%,520px); box-shadow:0 18px 36px rgba(0,0,0,.28);
      display:flex; flex-direction:column; gap:clamp(.75rem,2vh,1.2rem);
    }

    .reset-description { margin:0; font-size:clamp(.85rem,1.2vw,1rem); opacity:.85; }
    .reset-word {
      font-size:clamp(1rem,2.2vw,1.4rem);
      font-weight:700;
      letter-spacing:.08em;
      text-transform:uppercase;
      text-align:center;
      padding:.65rem 1rem;
      border-radius:12px;
      background:var(--pill);
    }
    #resetInput {
      padding:.65rem .85rem;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.2);
      color:var(--fg);
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.85rem,1.2vw,1rem);
      outline:none;
    }
    body.theme-light #resetInput {
      background:rgba(255,255,255,.65);
      border-color:rgba(0,0,0,.15);
      color:#0b0b0f;
    }
    .reset-actions { display:flex; justify-content:flex-end; gap:.75rem; }
    .reset-actions button {
      padding:.6rem 1.1rem;
      border:none;
      border-radius:10px;
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.8rem,1.15vw,.95rem);
      cursor:pointer;
      background:var(--pill);
      color:var(--fg);
    }
    .reset-actions button.confirm {
      background:linear-gradient(135deg, rgba(255,90,90,.45), rgba(190,0,0,.65));
      color:#fff;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
    }
    .reset-actions button.confirm:disabled {
      opacity:.6;
      cursor:not-allowed;
      box-shadow:none;
    }

    .modal-header { display:flex; justify-content:space-between; align-items:center; gap:1rem; }

    .modal-header h2 { margin:0; font-size:clamp(1.1rem,2.4vw,1.6rem); }

    .modal-close {
      background:transparent; border:none; color:var(--fg); font-size:1.6rem; cursor:pointer; line-height:1;
    }

  </style>
</head>
<body class="theme-rainbow">
  <div id="confettiLayer" aria-hidden="true"></div>
  <header class="app-header" role="banner">
    <nav class="nav-menu" aria-label="Navigation principale">
      <button class="nav-button active" type="button" data-page-target="mainPage">
        <span class="nav-label">Atoms</span>
      </button>
      <button class="nav-button" type="button" data-page-target="shopPage">
        <span class="nav-label">Shop</span>
      </button>
      <button class="nav-button" type="button" data-page-target="gachaPage">
        <span class="nav-label">Table</span>
      </button>
      <button class="nav-button" type="button" data-page-target="bonusPage">
        <span class="nav-label">Bonus</span>
      </button>
      <button class="nav-button" type="button" data-page-target="infosPage">
        <span class="nav-label">Infos</span>
      </button>
      <button class="nav-button" type="button" data-page-target="revivePage">
        <span class="nav-label">Revive</span>
      </button>
      <button class="nav-button" type="button" data-page-target="optionsPage">
        <span class="nav-label">Options</span>
      </button>
    </nav>
  </header>
  <main id="pageContainer">
    <!-- PAGE PRINCIPALE -->
    <section id="mainPage" class="page active" aria-labelledby="mainTitle">
      <h1 id="mainTitle" class="sr-only">ATOMS</h1>

      <div class="atomsCluster">
        <div class="atomsBox">
          <span class="atomsLabel">Atoms</span>
          <strong class="atomsValue" id="atoms">0.0</strong>
        </div>
        <div class="statPill statPill-apc">
          <span class="statLabel">APC</span>
          <span class="statValue" id="apc">1.0</span>
          <span class="frenzyStatus" id="apcFrenzyStatus" aria-live="polite"></span>
        </div>
        <div class="statPill statPill-aps">
          <span class="statLabel">APS</span>
          <span class="statValue" id="aps">0.0</span>
          <span class="frenzyStatus" id="apsFrenzyStatus" aria-live="polite"></span>
        </div>
      </div>

      <img class="atom" id="atomIcon" src="Assets/Image/Atom.png" alt="Icône d'atome" />

      <button id="frenzyOrb" class="frenzyOrb" type="button" aria-label="Activer la Frénésie APC" disabled></button>
      <button id="apsFrenzyOrb" class="frenzyOrb" type="button" aria-label="Activer la Frénésie APS" disabled></button>

      <div id="autoGachaPanel" class="auto-gacha-panel hidden" aria-live="polite">
        <div id="autoGachaHeader" class="auto-gacha-header">Tirage auto</div>
        <div class="auto-gacha-content">
          <span id="autoGachaName" class="auto-gacha-name">—</span>
          <span id="autoGachaResult" class="loot-result auto-gacha-result" data-base-class="loot-result auto-gacha-result">—</span>
        </div>
      </div>
    </section>

    <!-- PAGE SHOP -->
    <section id="shopPage" class="page" aria-labelledby="shopTitle">
      <h1 id="shopTitle" class="sr-only">Shop</h1>
      <div class="atomsCluster">
        <div class="atomsBox">
          <span class="atomsLabel">Atoms</span>
          <strong class="atomsValue" id="atomsShop">0.0</strong>
        </div>
        <div class="statPill statPill-apc">
          <span class="statLabel">APC</span>
          <span class="statValue" id="apcShop">1.0</span>
        </div>
        <div class="statPill statPill-aps">
          <span class="statLabel">APS</span>
          <span class="statValue" id="apsShop">0.0</span>
        </div>
      </div>
      <div class="shop-wrap">
        <div class="shop-grid">
          <div class="card shop-card">
            <h2 class="shop-card-title">Production</h2>
            <div class="shop-upgrade">
              <div class="shop-upgrade-header">
                <span class="shop-upgrade-label">APC</span>
                <span id="apcInfo" class="shop-upgrade-meta">Niveau 0</span>
              </div>
              <div class="shop-options">
                <button id="buyApc" class="shop-option" type="button">
                  <span class="option-tier">x1</span>
                  <span class="option-price">—</span>
                </button>
                <button id="buyApc10" class="shop-option" type="button">
                  <span class="option-tier">x10</span>
                  <span class="option-price">—</span>
                </button>
                <button id="buyApc100" class="shop-option" type="button">
                  <span class="option-tier">x100</span>
                  <span class="option-price">—</span>
                </button>
              </div>
            </div>
            <div class="shop-upgrade">
              <div class="shop-upgrade-header">
                <span class="shop-upgrade-label">APS</span>
                <span id="autoInfo" class="shop-upgrade-meta">Niveau 0</span>
              </div>
              <div class="shop-options">
                <button id="buyAuto" class="shop-option" type="button">
                  <span class="option-tier">x1</span>
                  <span class="option-price">—</span>
                </button>
                <button id="buyAuto10" class="shop-option" type="button">
                  <span class="option-tier">x10</span>
                  <span class="option-price">—</span>
                </button>
                <button id="buyAuto100" class="shop-option" type="button">
                  <span class="option-tier">x100</span>
                  <span class="option-price">—</span>
                </button>
              </div>
            </div>
            <div class="shop-upgrade shop-upgrade-single">
              <div class="shop-upgrade-header">
                <span class="shop-upgrade-label">Multiplicateur APC</span>
                <span id="apcMultiInfo" class="shop-upgrade-meta">Achats 0</span>
              </div>
              <button id="buyApcMulti" class="shop-option" type="button">
                <span class="option-tier">×2</span>
                <span class="option-price">—</span>
              </button>
            </div>
            <div class="shop-upgrade shop-upgrade-single">
              <div class="shop-upgrade-header">
                <span class="shop-upgrade-label">Multiplicateur APS</span>
                <span id="apsMultiInfo" class="shop-upgrade-meta">Achats 0</span>
              </div>
              <button id="buyApsMulti" class="shop-option" type="button">
                <span class="option-tier">×2</span>
                <span class="option-price">—</span>
              </button>
            </div>
          </div>

          <div class="card shop-card gacha-card">
            <h2 class="shop-card-title">Tirages Gacha</h2>
            <div class="shop-options gacha-options">
              <button id="rollBtn" class="shop-option" type="button">
                <span class="option-tier">x1</span>
                <span class="option-price" id="rollCostOnBtn">100.0</span>
              </button>
              <button id="roll10Btn" class="shop-option" type="button">
                <span class="option-tier">x10</span>
                <span class="option-price" id="roll10Cost">—</span>
              </button>
              <button id="roll100Btn" class="shop-option" type="button">
                <span class="option-tier">x100</span>
                <span class="option-price" id="roll100Cost">—</span>
              </button>
            </div>
            <div class="loot hidden" id="lastLootBox">
              <div class="loot-detail">
                <span id="lastLootName" class="loot-name">—</span>
                <span id="lastLootFam" class="loot-family">—</span>
              </div>
              <span id="lastLootType" class="loot-result" data-base-class="loot-result">—</span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- PAGE GACHA -->
    <section id="gachaPage" class="page" aria-labelledby="gachaTitle">
      <h1 id="gachaTitle" class="sr-only">Table</h1>
      <div class="gacha-wrap">
        <div id="periodicGrid" class="gacha-grid">
          <div id="gachaInfo" class="gacha-info">
            <div id="elementTitle" class="info-title">
              <span id="elementName">Clique un élément dans la grille</span>
              <span id="elementIsoCount" class="iso-count">—</span>
            </div>
            <div class="info-lines">
              <div class="info-line" id="elementFamily">Famille : —</div>
            </div>
          </div>
          <div id="awakenWrapper" class="awaken-box hidden">
            <button id="awakenBtn" class="awaken-btn" type="button">Éveil</button>
          </div>
        </div>
      </div>
    </section>

    <!-- PAGE BONUS -->
    <section id="bonusPage" class="page" aria-labelledby="bonusTitle">
      <h1 id="bonusTitle" class="sr-only">Bonus</h1>
      <div class="bonus-wrap">
        <h2 class="bonus-title">Bonus débloqués</h2>
        <div id="bonusList"><p>Aucun bonus actif pour le moment.</p></div>
      </div>
    </section>

    <!-- PAGE INFOS -->
    <section id="infosPage" class="page" aria-labelledby="infosTitle">
      <h1 id="infosTitle" class="sr-only">Infos</h1>
      <div class="info-grid">
        <article class="info-card">
          <h2>Session en cours</h2>
          <div class="info-metrics">
            <div class="info-row"><span>Total d'Atoms gagnés</span><strong id="infosSessionAtoms">0</strong></div>
            <div class="info-row"><span>Clics manuels</span><strong id="infosSessionClicks">0</strong></div>
            <div class="info-row"><span>Durée en ligne</span><strong id="infosSessionDuration">00:00:00</strong></div>
          </div>
        </article>
        <article class="info-card">
          <h2>Progression globale</h2>
          <div class="info-metrics">
            <div class="info-row"><span>Atoms (revive en cours)</span><strong id="infosReviveAtoms">0</strong></div>
            <div class="info-row"><span>Total d'Atoms</span><strong id="infosLifetimeAtoms">0</strong></div>
            <div class="info-row"><span>Clics (revive en cours)</span><strong id="infosReviveClicks">0</strong></div>
            <div class="info-row"><span>Clics totaux</span><strong id="infosLifetimeClicks">0</strong></div>
            <div class="info-row"><span>Revives complétés</span><strong id="infosReviveCount">0</strong></div>
            <div class="info-row"><span>Temps depuis le début</span><strong id="infosTotalRuntime">0 h 0 min</strong></div>
          </div>
        </article>
        <article class="info-card">
          <h2>Détails APC</h2>
          <div class="info-metrics">
            <div class="info-row"><span>Base</span><strong id="infosApcBase">0</strong></div>
            <div class="info-row"><span>Bonus plat</span><strong id="infosApcFlat">0</strong></div>
            <div class="info-row"><span>Après bonus</span><strong id="infosApcAfterFlat">0</strong></div>
            <div class="info-row info-row-multi">
              <span>Multiplicateurs</span>
              <ul class="multiplier-list" id="infosApcMultipliers"></ul>
            </div>
            <div class="info-row total"><span>Total APC</span><strong id="infosApcTotal">0</strong></div>
          </div>
        </article>
        <article class="info-card">
          <h2>Détails APS</h2>
          <div class="info-metrics">
            <div class="info-row"><span>Base</span><strong id="infosApsBase">0</strong></div>
            <div class="info-row"><span>Bonus plat</span><strong id="infosApsFlat">0</strong></div>
            <div class="info-row"><span>Après bonus</span><strong id="infosApsAfterFlat">0</strong></div>
            <div class="info-row info-row-multi">
              <span>Multiplicateurs</span>
              <ul class="multiplier-list" id="infosApsMultipliers"></ul>
            </div>
            <div class="info-row total"><span>Total APS</span><strong id="infosApsTotal">0</strong></div>
          </div>
        </article>
      </div>
    </section>

    <!-- PAGE REVIVE -->
    <section id="revivePage" class="page" aria-labelledby="reviveTitle">
      <h1 id="reviveTitle" class="sr-only">Revive</h1>
      <div class="revive-wrap">
        <article class="card revive-card">
          <h2 class="revive-heading">Module de renaissance</h2>
          <p class="revive-intro">Sacrifie ta progression actuelle pour recommencer une partie avec des bases plus solides et des bonus permanents.</p>
          <div class="revive-stats">
            <div class="revive-stat"><span>Revives réalisés</span><strong id="reviveCountStat">0</strong></div>
            <div class="revive-stat"><span>Base de départ APC/APS</span><strong id="reviveBaseStat">+0</strong></div>
            <div class="revive-stat"><span>Bonus par achat</span><strong id="reviveShopStat">+1</strong></div>
          </div>
          <div id="reviveOffer" class="revive-offer">
            <div class="revive-offer-details">
              <div class="revive-offer-line"><span>Coût</span><strong id="reviveCostValue">1.000b</strong></div>
              <div class="revive-offer-line"><span>Récompense</span><strong id="reviveRewardValue">+200 APC / APS</strong></div>
            </div>
            <button id="reviveBuyBtn" type="button">Déclencher la renaissance</button>
          </div>
          <p class="revive-note">Chaque renaissance remet à zéro tes Atoms, isotopes, bonus et améliorations, mais offre un bonus permanent d'APC/APS affiché ci-dessus et augmente le gain par achat du shop.</p>
          <p id="reviveLockedMessage" class="revive-locked hidden">Accumule suffisamment d'Atoms pour débloquer cette renaissance.</p>
        </article>
      </div>
    </section>

    <!-- PAGE OPTIONS -->
    <section id="optionsPage" class="page" aria-labelledby="optionsTitle">
      <h1 id="optionsTitle" class="sr-only">Options</h1>
      <div class="options-wrap">
        <div class="card options-card">
          <h2 class="options-title">Thème</h2>
          <div class="theme-selector" role="group" aria-label="Gestion du thème">
            <span class="theme-label">Thème</span>
            <div id="themeControls" aria-label="Sélecteur de thème">
              <button type="button" data-theme="light" aria-label="Activer le thème clair" title="Thème clair"></button>
              <button type="button" data-theme="dark" aria-label="Activer le thème sombre" title="Thème sombre"></button>
              <button type="button" data-theme="rainbow" aria-label="Activer le thème arc-en-ciel" title="Thème arc-en-ciel"></button>
            </div>
          </div>
        </div>
        <div class="card options-card">
          <h2 class="options-title">Gestion</h2>
          <p class="options-text">Réinitialise complètement ta sauvegarde et remet le jeu à zéro.</p>
          <button id="resetBtn" class="danger options-reset" type="button">Réinitialiser la partie</button>
        </div>
      </div>
    </section>
  </main>

  <div id="resetModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="resetTitle">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="resetTitle">Confirmer la réinitialisation</h2>
        <button id="closeReset" class="modal-close" type="button" aria-label="Fermer la fenêtre">×</button>
      </div>
      <p class="reset-description">Pour remettre la partie à zéro, recopie le mot ci-dessous puis valide.</p>
      <div id="resetWord" class="reset-word">—</div>
      <label class="reset-description" for="resetInput">Recopiez le mot affiché</label>
      <input id="resetInput" type="text" autocomplete="off" spellcheck="false" />
      <div class="reset-actions">
        <button id="cancelReset" type="button">Annuler</button>
        <button id="confirmReset" class="confirm" type="button" disabled>Réinitialiser</button>
      </div>
    </div>
  </div>

  <script>
    /* ===================== Données ===================== */

    // Familles & poids de tirage
    const FAMILIES = {
      ALK: { label:"Alcalins", weight:7, bonusDesc:"+1% chance de crit (max 50%), puis +10% dégâts critiques / bonus (set +5% chance)", bonusType:"crit" },
      HAL: { label:"Halogènes", weight:7, bonusDesc:"+1% APC / unique (set +10%)", bonusType:"apc" },
      NG : { label:"Gaz nobles", weight:7, bonusDesc:"+2% APS / unique (set +10%)", bonusType:"aps" },
      C  : { label:"Métaux de transition", weight:40, bonusDesc:"+1 APC & APS / élément unique (set +5)", bonusType:"flat" },
      AN : { label:"Actinides", weight:15, bonusDesc:"+1% APS offline / unique (set +50%)", bonusType:"offline" },
      LN : { label:"Lanthanides", weight:15, bonusDesc:"+0.5% multiplicateur global / unique (set +10%)", bonusType:"global" },
      MET: { label:"Métalloïdes", weight:7, bonusDesc:"+0.5% APC et APS / unique (set +5%)", bonusType:"hybrid" },
      NM : { label:"Non-métaux", weight:2, bonusDesc:"-1% coût du tirage par élément + éveil (set -10%)", bonusType:"infl" },
      AE : { label:"Alcalino-terreux", weight:7, bonusDesc:"Multiplicateur Frénésie : x5 APC +1 par élément/éveil (set +10)", bonusType:"frenzy" }
    };

    const FAMILY_COLORS = {
      ALK: { base:"#f8ead2", owned:"#e3ca9e" },
      AE : { base:"#e5f2d9", owned:"#c6d8b3" },
      C  : { base:"#dde8f7", owned:"#b9cbe6" },
      HAL: { base:"#e0f7f2", owned:"#b6ded0" },
      NG : { base:"#f0e7fb", owned:"#cec0ee" },
      LN : { base:"#fbe5f0", owned:"#e3bcd1" },
      AN : { base:"#ffe4e1", owned:"#efb7b2" },
      MET:{ base:"#e8f3ea", owned:"#c7dbce" },
      NM : { base:"#f3f3f3", owned:"#d8d8d8" }
    };

    const LOOT_RARITIES = [
      { key:"common", label:"Commun", weight:600, multiplier:1 },
      { key:"uncommon", label:"Peu commun", weight:250, multiplier:2 },
      { key:"rare", label:"Rare", weight:100, multiplier:5 },
      { key:"epic", label:"Épique", weight:40, multiplier:10 },
      { key:"legendary", label:"Légendaire", weight:9, multiplier:25 },
      { key:"mythic", label:"Mythique", weight:1, multiplier:100 }
    ];

    const AUTO_GACHA_TROPHIES = [
      { key:"auto1", threshold:1_000_000, name:"Réacteur automatique I", description:"Débloque un tirage gacha gratuit toutes les 10 s sur la page principale." },
      { key:"auto2", threshold:1_000_000_000, name:"Réacteur automatique II", description:"Réduit l'intervalle des tirages auto à 9 s." },
      { key:"auto3", threshold:1_000_000_000_000, name:"Réacteur automatique III", description:"Réduit l'intervalle des tirages auto à 8 s." },
      { key:"auto4", threshold:1_000_000_000_000_000, name:"Réacteur automatique IV", description:"Réduit l'intervalle des tirages auto à 7 s." },
      { key:"auto5", threshold:1_000_000_000_000_000_000, name:"Réacteur automatique V", description:"Réduit l'intervalle des tirages auto à 6 s." },
      { key:"auto6", threshold:1_000_000_000_000_000_000_000, name:"Réacteur automatique VI", description:"Réduit l'intervalle des tirages auto à 5 s." }
    ];

    const AWAKEN_MAX = 100;
    const AWAKEN_FINAL_COST = 1_000_000;
    const AWAKEN_BASE_COSTS = [5,10,25,50];
    const AWAKEN_COSTS = (()=>{
      const costs = AWAKEN_BASE_COSTS.slice(0, AWAKEN_MAX);
      if (costs.length === 0) costs.push(5);
      let remaining = Math.max(0, AWAKEN_MAX - costs.length);
      let prev = costs[costs.length - 1];
      while (remaining > 0){
        const ratio = Math.pow(AWAKEN_FINAL_COST / prev, 1 / remaining);
        const maxAllowed = AWAKEN_FINAL_COST - (remaining - 1) * 5;
        let next = prev * ratio;
        next = Math.round(next / 5) * 5;
        if (next > maxAllowed) next = maxAllowed;
        if (next <= prev) next = prev + 5;
        costs.push(Math.round(next));
        remaining--;
        prev = next;
      }
      costs[costs.length - 1] = AWAKEN_FINAL_COST;
      return costs;
    })();

    // Liste des métalloïdes classiques
    const METALLOIDS = new Set(["B","Si","Ge","As","Sb","Te","Po"]);

    // Noms FR (si un manque, on affichera le symbole)
    const NAMES_FR = {
      H:"Hydrogène", He:"Hélium", Li:"Lithium", Be:"Béryllium", B:"Bore", C:"Carbone", N:"Azote", O:"Oxygène", F:"Fluor", Ne:"Néon",
      Na:"Sodium", Mg:"Magnésium", Al:"Aluminium", Si:"Silicium", P:"Phosphore", S:"Soufre", Cl:"Chlore", Ar:"Argon",
      K:"Potassium", Ca:"Calcium", Sc:"Scandium", Ti:"Titane", V:"Vanadium", Cr:"Chrome", Mn:"Manganèse", Fe:"Fer", Co:"Cobalt", Ni:"Nickel", Cu:"Cuivre", Zn:"Zinc", Ga:"Gallium", Ge:"Germanium", As:"Arsenic", Se:"Sélénium", Br:"Brome", Kr:"Krypton",
      Rb:"Rubidium", Sr:"Strontium", Y:"Yttrium", Zr:"Zirconium", Nb:"Niobium", Mo:"Molybdène", Tc:"Technétium", Ru:"Ruthénium", Rh:"Rhodium", Pd:"Palladium", Ag:"Argent", Cd:"Cadmium", In:"Indium", Sn:"Étain", Sb:"Antimoine", Te:"Tellure", I:"Iode", Xe:"Xénon",
      Cs:"Césium", Ba:"Baryum", La:"Lanthane", Ce:"Cérium", Pr:"Praséodyme", Nd:"Néodyme", Pm:"Prométhium", Sm:"Samarium", Eu:"Europium", Gd:"Gadolinium", Tb:"Terbium", Dy:"Dysprosium", Ho:"Holmium", Er:"Erbium", Tm:"Thulium", Yb:"Ytterbium", Lu:"Lutécium",
      Hf:"Hafnium", Ta:"Tantale", W:"Tungstène", Re:"Rhénium", Os:"Osmium", Ir:"Iridium", Pt:"Platine", Au:"Or", Hg:"Mercure", Tl:"Thallium", Pb:"Plomb", Bi:"Bismuth", Po:"Polonium", At:"Astate", Rn:"Radon",
      Fr:"Francium", Ra:"Radium", Ac:"Actinium", Th:"Thorium", Pa:"Protactinium", U:"Uranium", Np:"Neptunium", Pu:"Plutonium", Am:"Américium", Cm:"Curium", Bk:"Berkélium", Cf:"Californium", Es:"Einsteinium", Fm:"Fermium", Md:"Mendélévium", No:"Nobélium", Lr:"Lawrencium",
      Rf:"Rutherfordium", Db:"Dubnium", Sg:"Seaborgium", Bh:"Bohrium", Hs:"Hassium", Mt:"Meitnérium", Ds:"Darmstadtium", Rg:"Roentgenium", Cn:"Copernicium", Nh:"Nihonium", Fl:"Flérovium", Mc:"Moscovium", Lv:"Livermorium", Ts:"Tennessine", Og:"Oganesson"
    };

    // Ordre officiel des 118 éléments (numéros atomiques croissants)
    // Source de référence : https://fr.periodic-table.io/
    const ORDERED_SYMBOLS = [
      "H","He","Li","Be","B","C","N","O","F","Ne",
      "Na","Mg","Al","Si","P","S","Cl","Ar",
      "K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn",
      "Ga","Ge","As","Se","Br","Kr",
      "Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd",
      "In","Sn","Sb","Te","I","Xe",
      "Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu",
      "Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn",
      "Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr",
      "Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"
    ];

    const ATOMIC_NUMBERS = ORDERED_SYMBOLS.reduce((map, symbol, idx) => {
      map[symbol] = idx + 1;
      return map;
    }, {});

    // Tableau périodique : périodes 1–7 (grille 18 colonnes)
    // Chaque ligne est un tableau de 18 symboles ("" = vide, "*" = emplacement de série f)
    const PERIODS = {
      1: ["H","","","","","","","","","","","","","","","","","He"],
      2: ["Li","Be","","","","","","","","","","","B","C","N","O","F","Ne"],
      3: ["Na","Mg","","","","","","","","","","","Al","Si","P","S","Cl","Ar"],
      4: ["K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr"],
      5: ["Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe"],
      6: ["Cs","Ba","*","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn"],
      7: ["Fr","Ra","*","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"]
    };

    // Séries f (Lanthanides & Actinides), 15 éléments chacune, placées en rangées séparées
    const LANTHANIDES = ["La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu"];
    const ACTINIDES   = ["Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr"];

    // Famille calculée selon groupe/période
    function familyOf(symbol, row, col){
      // Lanthanides / Actinides
      if (LANTHANIDES.includes(symbol)) return "LN";
      if (ACTINIDES.includes(symbol)) return "AN";
      // Groupes
      if (col===18) return "NG";
      if (col===17) return "HAL";
      if (col===1 && symbol!=="H") return "ALK";
      if (col===2) return "AE";
      // Métalloïdes
      if (METALLOIDS.has(symbol)) return "MET";
      // Non-métaux "classiques"
      if (["H","C","N","O","P","S","Se"].includes(symbol)) return "NM";
      // Métaux de transition (3–12) + autres métaux -> range dans C par simplicité de bonus
      if (col>=3 && col<=12) return "C";
      // Post-transition (13–16) => range dans C également pour ce design
      if (col>=13 && col<=16) return METALLOIDS.has(symbol) ? "MET" : "C";
      return "C";
    }

    function blockOf(symbol, period, col){
      if (LANTHANIDES.includes(symbol) || ACTINIDES.includes(symbol)) return "f";
      if (col <= 2) return "s";
      if (col >= 13) return "p";
      return "d";
    }

    // Construction de la liste complète 118 avec positions
    const ELEMENTS = [];
    for (let period=1; period<=7; period++){
      const row = PERIODS[period];
      for (let c=1; c<=18; c++){
        const sym = row[c-1] || "";
        if (!sym || sym==="*") continue;
        const Z = ATOMIC_NUMBERS[sym] ?? (ELEMENTS.length + 1);
        const family = familyOf(sym, period, c);
        const block = blockOf(sym, period, c);
        ELEMENTS.push({ Z, symbol: sym, name: NAMES_FR[sym]||sym, family, period, col:c, block });
      }
    }
    // Ajoute lanthanides (col 4 -> 18)
    LANTHANIDES.forEach((sym,i)=>{
      const col = 4 + i;
      const Z = ATOMIC_NUMBERS[sym] ?? (ELEMENTS.length + 1);
      ELEMENTS.push({ Z, symbol:sym, name:NAMES_FR[sym]||sym, family:"LN", period:6, col, block:"f", frow:"lan" });
    });
    // Ajoute actinides (col 4 -> 18)
    ACTINIDES.forEach((sym,i)=>{
      const col = 4 + i;
      const Z = ATOMIC_NUMBERS[sym] ?? (ELEMENTS.length + 1);
      ELEMENTS.push({ Z, symbol:sym, name:NAMES_FR[sym]||sym, family:"AN", period:7, col, block:"f", frow:"act" });
    });

    if (ELEMENTS.length !== ORDERED_SYMBOLS.length){
      console.warn(`[PeriodicTable] ${ELEMENTS.length} éléments chargés (attendu ${ORDERED_SYMBOLS.length}).`);
    }

    const ELEMENT_BY_SYMBOL = ELEMENTS.reduce((map, el)=>{
      map[el.symbol] = el;
      return map;
    }, {});

    const REVIVE_BASE_COST = 1_000_000_000_000;
    const REVIVE_COST_MULTIPLIER = 1000;
    const REVIVE_REWARDS = [200,500,1000,1500,2000,2500,3000,3500,4000,4500];

    // Tailles de set (pour les bonus de “set complet”)
    const FAMILY_SET_SIZES = {};
    for (const f of Object.keys(FAMILIES)) FAMILY_SET_SIZES[f] = ELEMENTS.filter(e=>e.family===f && !e.frow).length
      + (f==="LN"?LANTHANIDES.length:0) + (f==="AN"?ACTINIDES.length:0);

    /* ===================== État & persistance ===================== */
    const S0 = JSON.parse(localStorage.getItem("miniAtomState") || "{}");
    let atoms = toNonNegativeInt(S0.atoms ?? 0);
    let baseApc = Math.max(1, toNonNegativeInt(S0.apc ?? 1));
    let baseAps = toNonNegativeInt(S0.aps ?? 0);
    let apcLvl = toNonNegativeInt(S0.apcLvl ?? 0);
    let autoLvl = toNonNegativeInt(S0.autoLvl ?? 0);
    let apcMultiLvl = toNonNegativeInt(S0.apcMultiLvl ?? 0);
    let apsMultiLvl = toNonNegativeInt(S0.apsMultiLvl ?? 0);
    let totalAtoms = toNonNegativeInt(S0.totalAtoms ?? atoms);
    let manualClicksTotal = toNonNegativeInt(S0.manualClicks ?? 0);
    let reviveCount = toNonNegativeInt(S0.reviveCount ?? 0);
    let reviveRunAtoms = toNonNegativeInt(S0.reviveAtoms ?? totalAtoms);
    let reviveRunClicks = toNonNegativeInt(S0.reviveClicks ?? manualClicksTotal);
    let reviveUnlocked = (S0.reviveUnlocked === true) || reviveCount > 0;
    let gameStart = Number.isFinite(S0.gameStart) ? Math.max(0, Math.floor(S0.gameStart)) : Date.now();
    const reviveBaseValues = getReviveBaseStartValue(reviveCount);
    if (reviveBaseValues){
      baseApc = Math.max(baseApc, reviveBaseValues.apc);
      baseAps = Math.max(baseAps, reviveBaseValues.aps);
    }
    let trophies = {};
    if (S0.trophies && typeof S0.trophies === "object"){
      for (const trophy of AUTO_GACHA_TROPHIES){
        if (S0.trophies[trophy.key]) trophies[trophy.key] = S0.trophies[trophy.key];
      }
    }
    let last = S0.last ?? null;
    let sessionStartTime = Date.now();
    let sessionAtomsBaseline = totalAtoms;
    let sessionManualClicks = 0;
    let apcFrenzyEffects = [];
    let apsFrenzyEffects = [];
    let currentFrenzyMultiplierBase = 5;
    let apcFrenzyOrbTimeout = null;
    let apsFrenzyOrbTimeout = null;
    let apcFrenzyOrbVisible = false;
    let apsFrenzyOrbVisible = false;
    let autoGachaCooldown = 0;
    let lastAutoResult = null;

    // Gacha/collection
    function createDefaultGachaState(){
      return {
        pulls: 0,
        isotopes: 0,
        owned: {},   // symbol -> 0/1
        dupes: {},   // symbol -> n
        isoStock: {}, // symbol -> isotopes accumulés
        awakens: {},  // symbol -> niveau d'éveil
        rollCost: 100 // coût actuel d’un tirage (Atoms)
      };
    }
    const G0 = JSON.parse(localStorage.getItem("gacha") || "{}");
    let gacha = Object.assign(createDefaultGachaState(), G0);
    gacha.rollCost = Math.max(1, toNonNegativeInt(gacha.rollCost ?? 100));
    gacha.pulls = toNonNegativeInt(gacha.pulls || 0);

    if (!gacha.isoStock || typeof gacha.isoStock !== "object") gacha.isoStock = {};
    if (!gacha.awakens || typeof gacha.awakens !== "object") gacha.awakens = {};

    if (G0.isoStock){
      for (const [sym, amt] of Object.entries(G0.isoStock)){
        gacha.isoStock[sym] = Math.max(0, Math.floor(amt));
      }
    }
    syncTotalIsotopes();

    // Thème

    function saveAll(){
      localStorage.setItem("miniAtomState", JSON.stringify({
        atoms,
        apc: baseApc,
        aps: baseAps,
        apcLvl,
        autoLvl,
        apcMultiLvl,
        apsMultiLvl,
        totalAtoms,
        trophies,
        manualClicks: manualClicksTotal,
        gameStart,
        last: Date.now(),
        reviveCount,
        reviveAtoms: reviveRunAtoms,
        reviveClicks: reviveRunClicks,
        reviveUnlocked
      }));
      localStorage.setItem("gacha", JSON.stringify(gacha));
    }

    /* ===================== UI refs ===================== */

    const atomIcon = document.getElementById("atomIcon");
    const confettiLayer = document.getElementById("confettiLayer");
    const mainPageEl = document.getElementById("mainPage");
    const shopPageEl = document.getElementById("shopPage");
    const gachaPageEl = document.getElementById("gachaPage");
    const bonusPageEl = document.getElementById("bonusPage");
    const infosPageEl = document.getElementById("infosPage");
    const revivePageEl = document.getElementById("revivePage");
    const optionsPageEl = document.getElementById("optionsPage");
    const navButtons = Array.from(document.querySelectorAll(".nav-button[data-page-target]"));
    const reviveNavButton = navButtons.find(btn => btn.dataset.pageTarget === "revivePage");

    const reviveOfferEl = document.getElementById("reviveOffer");
    const reviveBuyBtn = document.getElementById("reviveBuyBtn");
    const reviveCostValueEl = document.getElementById("reviveCostValue");
    const reviveRewardValueEl = document.getElementById("reviveRewardValue");
    const reviveLockedMessageEl = document.getElementById("reviveLockedMessage");
    const reviveCountStatEl = document.getElementById("reviveCountStat");
    const reviveBaseStatEl = document.getElementById("reviveBaseStat");
    const reviveShopStatEl = document.getElementById("reviveShopStat");

    const elAtoms = document.getElementById("atoms");
    const elAps = document.getElementById("aps");
    const elApc = document.getElementById("apc");

    const elAtomsShop = document.getElementById("atomsShop");
    const elApsShop = document.getElementById("apsShop");
    const elApcShop = document.getElementById("apcShop");

    const elAtomsGacha = document.getElementById("atomsGacha");
    const elApsGacha = document.getElementById("apsGacha");
    const elApcGacha = document.getElementById("apcGacha");

    const btnBuyApc = document.getElementById("buyApc");
    const btnBuyApc10 = document.getElementById("buyApc10");
    const btnBuyApc100 = document.getElementById("buyApc100");
    const btnBuyAuto = document.getElementById("buyAuto");
    const btnBuyAuto10 = document.getElementById("buyAuto10");
    const btnBuyAuto100 = document.getElementById("buyAuto100");
    const btnBuyApcMulti = document.getElementById("buyApcMulti");
    const btnBuyApsMulti = document.getElementById("buyApsMulti");
    const infoApc = document.getElementById("apcInfo");
    const infoAuto = document.getElementById("autoInfo");
    const infoApcMulti = document.getElementById("apcMultiInfo");
    const infoApsMulti = document.getElementById("apsMultiInfo");

    const rollBtn = document.getElementById("rollBtn");
    const roll10Btn = document.getElementById("roll10Btn");
    const roll100Btn = document.getElementById("roll100Btn");
    const rollCostOnBtn = document.getElementById("rollCostOnBtn");
    const roll10CostOnBtn = document.getElementById("roll10Cost");
    const roll100CostOnBtn = document.getElementById("roll100Cost");
    const isotopesEl = document.getElementById("isotopes");

    const gridMain = document.getElementById("periodicGrid");
    const gachaInfoPanel = document.getElementById("gachaInfo");

    const elementName = document.getElementById("elementName");
    const elementIsoCount = document.getElementById("elementIsoCount");
    const elementFamily = document.getElementById("elementFamily");
    const awakenBtn = document.getElementById("awakenBtn");
    const awakenWrapper = document.getElementById("awakenWrapper");

    const bonusList = document.getElementById("bonusList");

    const infosSessionAtomsEl = document.getElementById("infosSessionAtoms");
    const infosSessionClicksEl = document.getElementById("infosSessionClicks");
    const infosSessionDurationEl = document.getElementById("infosSessionDuration");
    const infosReviveAtomsEl = document.getElementById("infosReviveAtoms");
    const infosLifetimeAtomsEl = document.getElementById("infosLifetimeAtoms");
    const infosReviveClicksEl = document.getElementById("infosReviveClicks");
    const infosLifetimeClicksEl = document.getElementById("infosLifetimeClicks");
    const infosReviveCountEl = document.getElementById("infosReviveCount");
    const infosTotalRuntimeEl = document.getElementById("infosTotalRuntime");
    const infosApcBaseEl = document.getElementById("infosApcBase");
    const infosApcFlatEl = document.getElementById("infosApcFlat");
    const infosApcAfterFlatEl = document.getElementById("infosApcAfterFlat");
    const infosApcMultipliersEl = document.getElementById("infosApcMultipliers");
    const infosApcTotalEl = document.getElementById("infosApcTotal");
    const infosApsBaseEl = document.getElementById("infosApsBase");
    const infosApsFlatEl = document.getElementById("infosApsFlat");
    const infosApsAfterFlatEl = document.getElementById("infosApsAfterFlat");
    const infosApsMultipliersEl = document.getElementById("infosApsMultipliers");
    const infosApsTotalEl = document.getElementById("infosApsTotal");

    const resetBtn = document.getElementById("resetBtn");
    const resetModal = document.getElementById("resetModal");
    const resetWordEl = document.getElementById("resetWord");
    const resetInput = document.getElementById("resetInput");
    const resetConfirmBtn = document.getElementById("confirmReset");
    const resetCancelBtn = document.getElementById("cancelReset");
    const resetCloseBtn = document.getElementById("closeReset");

    const lastLootBox = document.getElementById("lastLootBox");
    const lastLootName = document.getElementById("lastLootName");
    const lastLootFam = document.getElementById("lastLootFam");
    const lastLootType = document.getElementById("lastLootType");
    const apcFrenzyStatusEl = document.getElementById("apcFrenzyStatus");
    const apsFrenzyStatusEl = document.getElementById("apsFrenzyStatus");
    const apcFrenzyOrbEl = document.getElementById("frenzyOrb");
    const apsFrenzyOrbEl = document.getElementById("apsFrenzyOrb");
    const autoGachaPanel = document.getElementById("autoGachaPanel");
    const autoGachaHeader = document.getElementById("autoGachaHeader");
    const autoGachaName = document.getElementById("autoGachaName");
    const autoGachaResultEl = document.getElementById("autoGachaResult");

    function setLootResultClass(cls, target = lastLootType){
      if (!target) return;
      const baseClass = target.dataset.baseClass || "loot-result";
      target.className = baseClass;
      if (cls) target.classList.add(cls);
    }

    const themeButtons = Array.from(document.querySelectorAll('#themeControls button'));

    const CONFETTI_LIFETIME = 2500;
    const CONFETTI_COUNT = 36;
    const CONFETTI_PALETTES = {
      dark: ['#fff3b0','#ffadad','#cdb4db','#90f1ef','#ffd6a5','#f9f871'],
      light: ['#5f0f40','#9a031e','#fb8b24','#0f4c5c','#335c67','#3a86ff'],
      rainbow: ['#ff595e','#ffca3a','#8ac926','#1982c4','#6a4c93','#ff924c']
    };

    let currentTheme = null;
    let currentElement = null;
    let currentIsoDiscount = 0;
    let currentRollDiscount = 0;
    const cellMap = new Map();
    let currentResetWord = "";
    let critFlashTimeout = null;

    function createSoundPlayer(src, { poolSize = 4, volume = 1 } = {}){
      const players = [];
      for (let i = 0; i < poolSize; i++){
        const audio = new Audio(src);
        audio.preload = "auto";
        audio.volume = volume;
        audio.load();
        players.push(audio);
      }
      let nextIndex = 0;
      return function play(){
        if (!players.length) return;
        const audio = players[nextIndex];
        nextIndex = (nextIndex + 1) % players.length;
        try {
          audio.currentTime = 0;
          const playPromise = audio.play();
          if (playPromise && typeof playPromise.catch === "function"){
            playPromise.catch(()=>{});
          }
        } catch (err) {
          /* ignore playback errors (autoplay restrictions, etc.) */
        }
      };
    }

    const playPopSound = createSoundPlayer("Assets/Sounds/pop.mp3", { poolSize:6, volume:0.45 });
    const playCritSound = createSoundPlayer("Assets/Sounds/crit.mp3", { poolSize:3, volume:0.6 });


    // Thème (après récupération des boutons pour éviter les erreurs à l'initialisation)
    const savedTheme = localStorage.getItem("theme") || "rainbow";
    currentTheme = savedTheme;
    function applyTheme(theme, { persist = true } = {}){
      document.body.classList.remove("theme-light","theme-dark","theme-rainbow");
      document.body.classList.add(`theme-${theme}`);
      if (persist) localStorage.setItem("theme", theme);
      themeButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.theme === theme));
      currentTheme = theme;
    }
    applyTheme(savedTheme, { persist:false });


    /* ===================== Helpers ===================== */
    const RESET_WORDS = [
      "quantique","neutron","proton","orbite","fusion","plasma","noyau","isotope","photon","boson","quark","ion"
    ];

    const MULTIPLIER_SCALE = 1000;
    const CHANCE_SCALE = 1000;

    const SUFFIXES = (()=>{
      const list = ["", "m", "b", "t"];
      const prefixes = ["S","T","U","V","W","X","Y","Z"];
      for (const prefix of prefixes){
        for (let i = 0; i < 26; i++){
          list.push(`${prefix}${String.fromCharCode(97 + i)}`);
        }
      }
      return list;
    })();

    function toInteger(value){
      if (!Number.isFinite(value)) return 0;
      return value >= 0 ? Math.floor(value) : Math.ceil(value);
    }

    function toNonNegativeInt(value){
      const intVal = toInteger(value);
      return intVal < 0 ? 0 : intVal;
    }

    function checkReviveUnlock(){
      if (!reviveUnlocked && atoms >= getReviveCostValue(0)){
        reviveUnlocked = true;
        updateReviveNavState();
        updateReviveUI();
      }
    }

    function addAtoms(amount, { silent = false } = {}){
      const gain = Math.max(0, toNonNegativeInt(amount));
      if (!gain) return false;
      atoms = Math.max(0, atoms + gain);
      totalAtoms = Math.max(0, totalAtoms + gain);
      reviveRunAtoms = Math.max(0, reviveRunAtoms + gain);
      checkReviveUnlock();
      checkTrophies({ silent });
      return true;
    }

    function splitIntoGroups(value){
      const groups = [];
      let remaining = value;
      while (remaining >= 1000){
        groups.push(remaining % 1000);
        remaining = Math.floor(remaining / 1000);
      }
      groups.push(remaining);
      return groups.reverse();
    }

    function joinGroups(groups){
      return groups.map((group, idx)=> idx === 0 ? String(group) : String(group).padStart(3, '0')).join('.');
    }

    function formatWithSuffix(value){
      const negative = value < 0;
      const absVal = Math.abs(value);
      const groups = splitIntoGroups(absVal);
      let formatted;
      if (groups.length >= 3){
        const suffixIndex = Math.min(groups.length - 2, SUFFIXES.length - 1);
        const suffix = SUFFIXES[suffixIndex];
        const head = groups[0];
        const next = groups[1];
        formatted = `${head}.${String(next).padStart(3, '0')}${suffix}`;
      } else {
        formatted = joinGroups(groups);
      }
      return negative && absVal > 0 ? `-${formatted}` : formatted;
    }

    function formatNumber(value){
      return formatWithSuffix(toInteger(value));
    }

    function getReviveRewardValue(index){
      const idx = Math.max(0, Math.floor(Number.isFinite(index) ? index : Number(index) || 0));
      if (idx < REVIVE_REWARDS.length){
        return Math.max(0, Math.floor(REVIVE_REWARDS[idx] || 0));
      }
      const lastValue = REVIVE_REWARDS.length
        ? Math.max(0, Math.floor(REVIVE_REWARDS[REVIVE_REWARDS.length - 1] || 0))
        : 0;
      const extra = Math.max(0, idx - (REVIVE_REWARDS.length - 1));
      const value = lastValue + extra * 500;
      if (!Number.isFinite(value) || value > Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;
      return Math.max(0, Math.floor(value));
    }

    function getReviveCostValue(index){
      const idx = Math.max(0, Math.floor(Number.isFinite(index) ? index : Number(index) || 0));
      let cost = REVIVE_BASE_COST;
      for (let i = 0; i < idx; i++){
        cost *= REVIVE_COST_MULTIPLIER;
        if (!Number.isFinite(cost) || cost > Number.MAX_VALUE){
          return Number.MAX_VALUE;
        }
      }
      if (!Number.isFinite(cost)) return Number.MAX_VALUE;
      return Math.max(1, Math.floor(cost));
    }

    function getReviveTotalBonus(count = reviveCount){
      const c = Math.max(0, Math.floor(Number.isFinite(count) ? count : Number(count) || 0));
      if (c <= 0) return 0;
      let total = 0;
      for (let i = 0; i < c; i++){
        total += getReviveRewardValue(i);
        if (!Number.isFinite(total) || total > Number.MAX_SAFE_INTEGER){
          return Number.MAX_SAFE_INTEGER;
        }
      }
      return Math.max(0, Math.floor(total));
    }

    function getReviveBaseStartValue(count = reviveCount){
      const c = Math.max(0, Math.floor(Number.isFinite(count) ? count : Number(count) || 0));
      if (c <= 0) return { apc: 1, aps: 0 };
      const total = getReviveTotalBonus(c);
      if (!Number.isFinite(total) || total > Number.MAX_SAFE_INTEGER){
        return { apc: Number.MAX_SAFE_INTEGER, aps: Number.MAX_SAFE_INTEGER };
      }
      const base = Math.max(0, Math.floor(total));
      return { apc: Math.max(1, base), aps: Math.max(0, base) };
    }

    function getReviveShopIncrementValue(count = reviveCount){
      const c = Math.max(0, Math.floor(Number.isFinite(count) ? count : Number(count) || 0));
      let increment = 1;
      for (let i = 0; i < c; i++){
        if (!Number.isFinite(increment) || increment > Number.MAX_SAFE_INTEGER / 2){
          return Number.MAX_SAFE_INTEGER;
        }
        increment *= 2;
      }
      return Math.max(1, Math.floor(increment));
    }

    function getReviveTier(index = reviveCount){
      const idx = Math.max(0, Math.floor(Number.isFinite(index) ? index : Number(index) || 0));
      return {
        index: idx,
        cost: getReviveCostValue(idx),
        reward: getReviveRewardValue(idx)
      };
    }

    function scaledToPercent(value){
      return Math.floor((value * 100 + Math.floor(MULTIPLIER_SCALE / 2)) / MULTIPLIER_SCALE);
    }

    function chanceScaledToPercent(value){
      return Math.floor((value * 100 + Math.floor(CHANCE_SCALE / 2)) / CHANCE_SCALE);
    }
    function formatSessionDuration(ms){
      const totalSeconds = Math.max(0, Math.floor(ms / 1000));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function formatRuntimeDuration(ms){
      const totalMinutes = Math.max(0, Math.floor(ms / 60000));
      const totalHours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      if (totalHours >= 24){
        const days = Math.floor(totalHours / 24);
        const hours = totalHours % 24;
        return `${days} j ${hours} h ${minutes} min`;
      }
      return `${totalHours} h ${minutes} min`;
    }

    function formatMultiplier(value){
      if (!Number.isFinite(value) || value <= 0) return '×0';
      let precision = 2;
      if (value >= 1000) precision = 0;
      else if (value >= 10) precision = 1;
      return `×${value.toFixed(precision)}`;
    }

    function renderMultiplierList(target, items){
      if (!target) return;
      if (!Array.isArray(items) || items.length === 0){
        target.innerHTML = '<li class="multiplier-item"><span>Aucun bonus</span><strong>×1.00</strong></li>';
        return;
      }
      target.innerHTML = items.map(item => {
        const data = item || {};
        const label = data.label || '';
        const value = Number.isFinite(data.value) ? data.value : 1;
        return `<li class="multiplier-item"><span>${label}</span><strong>${formatMultiplier(value)}</strong></li>`;
      }).join("");
    }
    const normalizeWord = str => (str || "").trim().toLowerCase();

    const APC_FRENZY_DURATION_MS = 30_000;
    const APS_FRENZY_DURATION_MS = 60_000;
    const FRENZY_SPAWN_DENOM = 120;
    const FRENZY_ORB_LIFETIME_MS = 8_000;

    function getConfettiPalette(){
      return CONFETTI_PALETTES[currentTheme] || CONFETTI_PALETTES.dark;
    }

    function getAtomCenter(){
      if (!atomIcon) return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      const rect = atomIcon.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }

    function spawnConfettiBurst(origin = getAtomCenter(), pieces = CONFETTI_COUNT){
      if (!confettiLayer) return;
      const palette = getConfettiPalette();
      for (let i = 0; i < pieces; i++){
        const piece = document.createElement('span');
        piece.className = 'confetti-piece';

        const baseColor = palette[Math.floor(Math.random() * palette.length)];
        const accentColor = palette[Math.floor(Math.random() * palette.length)];
        const useGradient = Math.random() > 0.6 && baseColor !== accentColor;
        const gradientAngle = Math.floor(Math.random() * 360);
        piece.style.background = useGradient ? `linear-gradient(${gradientAngle}deg, ${baseColor}, ${accentColor})` : baseColor;

        const width = 6 + Math.random() * 10;
        const height = width * (0.6 + Math.random() * 0.9);
        piece.style.width = `${width.toFixed(2)}px`;
        piece.style.height = `${height.toFixed(2)}px`;
        piece.style.boxShadow = `0 0 8px ${baseColor}44`;

        const shapeRoll = Math.random();
        if (shapeRoll < 0.3){
          piece.style.borderRadius = `${Math.floor(Math.random() * 50)}%`;
        } else if (shapeRoll < 0.55){
          piece.style.borderRadius = '999px';
        } else if (shapeRoll < 0.8){
          piece.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
        } else {
          piece.style.clipPath = 'polygon(0% 0%, 80% 10%, 100% 100%, 20% 90%)';
        }

        const left = origin.x - width / 2;
        const top = origin.y - height / 2;
        piece.style.left = `${left}px`;
        piece.style.top = `${top}px`;

        confettiLayer.appendChild(piece);

        const angle = Math.random() * Math.PI * 2;
        const distance = 120 + Math.random() * 160;
        const driftX = Math.cos(angle) * distance;
        const driftY = Math.sin(angle) * distance + 80 + Math.random() * 80;
        const rotateStart = Math.random() * 360;
        const rotateDirection = Math.random() > 0.5 ? 1 : -1;
        const rotateEnd = rotateStart + rotateDirection * (360 + Math.random() * 540);
        const scaleEnd = 0.4 + Math.random() * 0.35;

        const animation = piece.animate([
          { transform: `translate3d(0,0,0) rotate(${rotateStart}deg) scale(1)`, opacity: 1 },
          { offset: 0.6, opacity: 1 },
          { transform: `translate3d(${driftX}px, ${driftY}px, 0) rotate(${rotateEnd}deg) scale(${scaleEnd})`, opacity: 0 }
        ], {
          duration: CONFETTI_LIFETIME,
          easing: 'cubic-bezier(0.32, 0.12, 0.17, 1)'
        });

        animation.onfinish = () => piece.remove();
        animation.oncancel = () => piece.remove();
      }
    }

    function getUnlockedAutoTrophiesCount(){
      return AUTO_GACHA_TROPHIES.reduce((count, trophy) => count + (trophies[trophy.key] ? 1 : 0), 0);
    }

    function hasAutoGachaUnlocked(){
      return getUnlockedAutoTrophiesCount() > 0;
    }

    function getAutoGachaInterval(){
      const unlocked = getUnlockedAutoTrophiesCount();
      if (unlocked <= 0) return null;
      const extra = Math.min(unlocked - 1, AUTO_GACHA_TROPHIES.length - 1);
      return Math.max(1, 10 - extra);
    }

    function resetAutoGachaCooldown(){
      const interval = getAutoGachaInterval();
      if (interval){
        if (autoGachaCooldown <= 0 || autoGachaCooldown > interval){
          autoGachaCooldown = interval;
        } else {
          autoGachaCooldown = Math.min(autoGachaCooldown, interval);
        }
      } else {
        autoGachaCooldown = 0;
      }
    }

    function updateAutoGachaHeader(){
      if (!autoGachaHeader) return;
      const interval = getAutoGachaInterval();
      autoGachaHeader.textContent = interval ? `Tirage auto (${interval}s)` : "Tirage auto";
    }

    function updateAutoGachaPanel(){
      if (!autoGachaPanel) return;
      const isMainActive = !!(mainPageEl && mainPageEl.classList.contains('active'));
      const shouldShow = hasAutoGachaUnlocked() && lastAutoResult && isMainActive;
      autoGachaPanel.classList.toggle('hidden', !shouldShow);
    }

    function showAutoGachaResult(result){
      lastAutoResult = result;
      if (autoGachaName && result?.element){
        autoGachaName.textContent = `${result.element.name} (${result.element.symbol})`;
      }
      if (autoGachaResultEl){
        if (result?.isNew){
          setLootResultClass('is-new', autoGachaResultEl);
          autoGachaResultEl.textContent = 'Nouveau!';
        } else if (result?.lootRarity){
          setLootResultClass(`rarity-${result.lootRarity.key}`, autoGachaResultEl);
          autoGachaResultEl.textContent = `Isotopes ×${result.lootRarity.multiplier}`;
        } else {
          setLootResultClass(null, autoGachaResultEl);
          autoGachaResultEl.textContent = '—';
        }
      }
      updateAutoGachaPanel();
    }

    function checkTrophies({ silent = false } = {}){
      let unlocked = false;
      for (const trophy of AUTO_GACHA_TROPHIES){
        if (!trophies[trophy.key] && totalAtoms >= trophy.threshold){
          trophies[trophy.key] = Date.now();
          unlocked = true;
          if (!silent) spawnConfettiBurst();
        }
      }
      if (unlocked){
        resetAutoGachaCooldown();
        updateAutoGachaHeader();
        updateAutoGachaPanel();
        refreshBonusList();
      }
      return unlocked;
    }

    function performAutoGachaRoll(){
      const result = rollGacha({ free:true, origin:"auto" });
      if (!result) return false;
      saveAndUpdate();
      showAutoGachaResult(result);
      return true;
    }

    function handleAutoGachaTick(deltaSeconds = 1){
      const interval = getAutoGachaInterval();
      if (!interval){
        autoGachaCooldown = 0;
        return;
      }
      if (!(mainPageEl && mainPageEl.classList.contains('active'))) return;
      autoGachaCooldown = Math.max(0, autoGachaCooldown - deltaSeconds);
      if (autoGachaCooldown > 0) return;
      if (!performAutoGachaRoll()){
        // Si le tirage échoue, on retente après un intervalle complet.
      }
      autoGachaCooldown = interval;
    }

    function pruneApcFrenzyEffects(now = Date.now()){
      apcFrenzyEffects = apcFrenzyEffects.filter(effect => effect.expiresAt > now);
    }

    function pruneApsFrenzyEffects(now = Date.now()){
      apsFrenzyEffects = apsFrenzyEffects.filter(effect => effect.expiresAt > now);
    }

    function getActiveApcFrenzyMultiplier(){
      pruneApcFrenzyEffects();
      if (!apcFrenzyEffects.length) return 1;
      return apcFrenzyEffects.reduce((mul, effect) => mul * effect.multiplier, 1);
    }

    function getActiveApsFrenzyMultiplier(){
      pruneApsFrenzyEffects();
      if (!apsFrenzyEffects.length) return 1;
      return apsFrenzyEffects.reduce((mul, effect) => mul * effect.multiplier, 1);
    }

    function getApcFrenzyStackCount(){
      pruneApcFrenzyEffects();
      return apcFrenzyEffects.length;
    }

    function getApsFrenzyStackCount(){
      pruneApsFrenzyEffects();
      return apsFrenzyEffects.length;
    }

    function getLongestApcFrenzyRemaining(){
      pruneApcFrenzyEffects();
      if (!apcFrenzyEffects.length) return 0;
      const now = Date.now();
      return Math.max(...apcFrenzyEffects.map(effect => Math.max(0, effect.expiresAt - now)));
    }

    function getLongestApsFrenzyRemaining(){
      pruneApsFrenzyEffects();
      if (!apsFrenzyEffects.length) return 0;
      const now = Date.now();
      return Math.max(...apsFrenzyEffects.map(effect => Math.max(0, effect.expiresAt - now)));
    }

    function triggerApcFrenzyBonus(){
      const multiplier = Math.max(1, currentFrenzyMultiplierBase);
      const expiresAt = Date.now() + APC_FRENZY_DURATION_MS;
      apcFrenzyEffects.push({ multiplier, expiresAt });
      spawnConfettiBurst(getAtomCenter(), Math.max(12, Math.floor(CONFETTI_COUNT / 2)));
      updateUI();
    }

    function triggerApsFrenzyBonus(){
      const multiplier = Math.max(1, currentFrenzyMultiplierBase);
      const expiresAt = Date.now() + APS_FRENZY_DURATION_MS;
      apsFrenzyEffects.push({ multiplier, expiresAt });
      spawnConfettiBurst(getAtomCenter(), Math.max(12, Math.floor(CONFETTI_COUNT / 2)));
      updateUI();
    }

    function hideApcFrenzyOrb(){
      if (apcFrenzyOrbTimeout){
        clearTimeout(apcFrenzyOrbTimeout);
        apcFrenzyOrbTimeout = null;
      }
      if (apcFrenzyOrbEl){
        apcFrenzyOrbEl.classList.remove('visible');
        apcFrenzyOrbEl.disabled = true;
        if (document.activeElement === apcFrenzyOrbEl) apcFrenzyOrbEl.blur();
      }
      apcFrenzyOrbVisible = false;
    }

    function hideApsFrenzyOrb(){
      if (apsFrenzyOrbTimeout){
        clearTimeout(apsFrenzyOrbTimeout);
        apsFrenzyOrbTimeout = null;
      }
      if (apsFrenzyOrbEl){
        apsFrenzyOrbEl.classList.remove('visible');
        apsFrenzyOrbEl.disabled = true;
        if (document.activeElement === apsFrenzyOrbEl) apsFrenzyOrbEl.blur();
      }
      apsFrenzyOrbVisible = false;
    }

    function spawnApcFrenzyOrb(){
      if (!apcFrenzyOrbEl || apcFrenzyOrbVisible) return;
      if (!mainPageEl || !mainPageEl.classList.contains('active')) return;
      const mainRect = mainPageEl.getBoundingClientRect();
      const atomRect = atomIcon ? atomIcon.getBoundingClientRect() : null;
      if (!atomRect) return;
      const centerX = atomRect.left + atomRect.width / 2 - mainRect.left;
      const centerY = atomRect.top + atomRect.height / 2 - mainRect.top;
      const radius = atomRect.width * (0.6 + Math.random() * 0.5);
      const angle = Math.random() * Math.PI * 2;
      let targetX = centerX + Math.cos(angle) * radius;
      let targetY = centerY + Math.sin(angle) * radius;
      const halfWidth = atomRect.width / 2;
      const halfHeight = atomRect.height / 2;
      const marginX = Math.max(halfWidth, Math.max(24, atomRect.width * 0.3));
      const marginY = Math.max(halfHeight, Math.max(24, atomRect.height * 0.3));
      targetX = Math.min(Math.max(targetX, marginX), Math.max(marginX, mainRect.width - marginX));
      targetY = Math.min(Math.max(targetY, marginY), Math.max(marginY, mainRect.height - marginY));
      apcFrenzyOrbEl.style.left = `${targetX}px`;
      apcFrenzyOrbEl.style.top = `${targetY}px`;
      apcFrenzyOrbEl.classList.add('visible');
      apcFrenzyOrbEl.disabled = false;
      apcFrenzyOrbVisible = true;
      if (apcFrenzyOrbTimeout) clearTimeout(apcFrenzyOrbTimeout);
      apcFrenzyOrbTimeout = setTimeout(()=> hideApcFrenzyOrb(), FRENZY_ORB_LIFETIME_MS);
    }

    function spawnApsFrenzyOrb(){
      if (!apsFrenzyOrbEl || apsFrenzyOrbVisible) return;
      if (!mainPageEl || !mainPageEl.classList.contains('active')) return;
      const mainRect = mainPageEl.getBoundingClientRect();
      const atomRect = atomIcon ? atomIcon.getBoundingClientRect() : null;
      if (!atomRect) return;
      const centerX = atomRect.left + atomRect.width / 2 - mainRect.left;
      const centerY = atomRect.top + atomRect.height / 2 - mainRect.top;
      const radius = atomRect.width * (0.6 + Math.random() * 0.5);
      const angle = Math.random() * Math.PI * 2;
      let targetX = centerX + Math.cos(angle) * radius;
      let targetY = centerY + Math.sin(angle) * radius;
      const halfWidth = atomRect.width / 2;
      const halfHeight = atomRect.height / 2;
      const marginX = Math.max(halfWidth, Math.max(24, atomRect.width * 0.3));
      const marginY = Math.max(halfHeight, Math.max(24, atomRect.height * 0.3));
      targetX = Math.min(Math.max(targetX, marginX), Math.max(marginX, mainRect.width - marginX));
      targetY = Math.min(Math.max(targetY, marginY), Math.max(marginY, mainRect.height - marginY));
      apsFrenzyOrbEl.style.left = `${targetX}px`;
      apsFrenzyOrbEl.style.top = `${targetY}px`;
      apsFrenzyOrbEl.classList.add('visible');
      apsFrenzyOrbEl.disabled = false;
      apsFrenzyOrbVisible = true;
      if (apsFrenzyOrbTimeout) clearTimeout(apsFrenzyOrbTimeout);
      apsFrenzyOrbTimeout = setTimeout(()=> hideApsFrenzyOrb(), FRENZY_ORB_LIFETIME_MS);
    }

    function checkApcFrenzySpawn(){
      if (apcFrenzyOrbVisible) return;
      if (!mainPageEl || !mainPageEl.classList.contains('active')) return;
      if (Math.floor(Math.random() * FRENZY_SPAWN_DENOM) === 0) spawnApcFrenzyOrb();
    }

    function checkApsFrenzySpawn(){
      if (apsFrenzyOrbVisible) return;
      if (!mainPageEl || !mainPageEl.classList.contains('active')) return;
      if (Math.floor(Math.random() * FRENZY_SPAWN_DENOM) === 0) spawnApsFrenzyOrb();
    }

    function rollLootRarity(){
      const totalWeight = LOOT_RARITIES.reduce((sum, rarity)=> sum + (rarity.weight || 0), 0);
      if (totalWeight <= 0) return LOOT_RARITIES[0];
      let roll = Math.floor(Math.random() * totalWeight);
      let acc = 0;
      for (const rarity of LOOT_RARITIES){
        acc += rarity.weight || 0;
        if (roll < acc) return rarity;
      }
      return LOOT_RARITIES[LOOT_RARITIES.length - 1];
    }

    function getIsoStock(symbol){
      return Math.max(0, Math.floor((gacha.isoStock && gacha.isoStock[symbol]) || 0));
    }

    function computeTotalIsotopes(){
      return Object.values(gacha.isoStock || {}).reduce((sum, val)=> sum + Math.max(0, Math.floor(val||0)), 0);
    }

    function syncTotalIsotopes(){
      gacha.isotopes = computeTotalIsotopes();
    }

    function addIsotopes(symbol, amount){
      if (!amount) return;
      const current = getIsoStock(symbol);
      gacha.isoStock[symbol] = current + Math.max(0, Math.floor(amount));
      syncTotalIsotopes();
    }

    function spendIsotopes(symbol, amount){
      const cost = Math.max(0, Math.floor(amount));
      if (cost === 0) return true;
      const current = getIsoStock(symbol);
      if (current < cost) return false;
      const remaining = current - cost;
      if (remaining > 0) gacha.isoStock[symbol] = remaining; else delete gacha.isoStock[symbol];
      syncTotalIsotopes();
      return true;
    }

    function getAwakenLevel(symbol){
      return Math.min(AWAKEN_MAX, (gacha.awakens && gacha.awakens[symbol]) || 0);
    }

    function setAwakenLevel(symbol, level){
      gacha.awakens[symbol] = Math.min(AWAKEN_MAX, Math.max(0, Math.floor(level)));
    }

    function getAwakenMultiplier(level){
      return Math.pow(2, Math.max(0, Math.min(level, AWAKEN_MAX)));
    }

    function getAwakenCost(level){
      return AWAKEN_COSTS[level] ?? null;
    }

    function getDiscountedAwakenCost(level, isoDiscountScaled){
      const baseCost = getAwakenCost(level);
      if (baseCost == null) return null;
      if (baseCost === 0) return 0;
      const discount = Math.max(0, Math.min(isoDiscountScaled || 0, MULTIPLIER_SCALE));
      const numerator = (MULTIPLIER_SCALE - discount) * baseCost + (MULTIPLIER_SCALE - 1);
      return Math.max(1, Math.floor(numerator / MULTIPLIER_SCALE));
    }

    // Probabilités familiales (pondérées)
    function pickFamily(){
      const entries = Object.entries(FAMILIES).filter(([k,v]) => (v.weight || 0) > 0);
      if (!entries.length) return null;
      const sum = entries.reduce((s,[,v])=> s + (v.weight || 0), 0);
      if (sum <= 0) return entries[0][0];
      let roll = Math.floor(Math.random() * sum);
      let acc = 0;
      for (const [key, v] of entries){
        acc += v.weight || 0;
        if (roll < acc) return key;
      }
      return entries[0][0];
    }

    function animateAtom(isCrit = false){
      playPopSound();
      if (!atomIcon){
        if (isCrit){
          playCritSound();
          spawnConfettiBurst();
        }
        return;
      }
      atomIcon.classList.add("enflé");
      atomIcon.classList.add("colorShift");
      setTimeout(()=>{
        atomIcon.classList.remove("enflé");
        atomIcon.classList.remove("colorShift");
      }, 220);
      if (isCrit){
        playCritSound();
        atomIcon.classList.add("crit");
        spawnConfettiBurst();
        if (critFlashTimeout) clearTimeout(critFlashTimeout);
        critFlashTimeout = setTimeout(()=>{
          atomIcon.classList.remove("crit");
          critFlashTimeout = null;
        }, 650);
      }
    }

    function saveAndUpdate(){ saveAll(); updateUI(); }

    /* ===================== Bonus de familles ===================== */
    function computeFamilyEffects(){
      // Compte uniques possédés par famille
      const perFamCount = {};
      const perFamWeight = {};
      for (const f of Object.keys(FAMILIES)){
        perFamCount[f] = 0;
        perFamWeight[f] = 0;
      }
      for (const el of ELEMENTS){
        if (!gacha.owned[el.symbol]) continue;
        const lvl = getAwakenLevel(el.symbol);
        perFamCount[el.family] = (perFamCount[el.family]||0) + 1;
        perFamWeight[el.family] = (perFamWeight[el.family]||0) + getAwakenMultiplier(lvl);
      }

      let critUnits = 0;
      let apcMul = MULTIPLIER_SCALE;
      let apsMul = MULTIPLIER_SCALE;
      let inflRed = 0;
      let offlineBonus = 0;
      let globalMul = MULTIPLIER_SCALE;
      let isoDiscount = 0;
      let apcFlat = 0;
      let apsFlat = 0;

      // hybrid (métalloïdes)
      let hybridAPC = 0, hybridAPS = 0;
      let frenzyBase = 5;

      for (const [f, n] of Object.entries(perFamWeight)){
        if (!n) continue;
        switch(f){
          case "ALK": critUnits += n; break;
          case "HAL": apcMul += n * 10; break;
          case "NG" : apsMul += n * 20; break;
          case "C"  : apcFlat += n; apsFlat += n; break;
          case "AN" : offlineBonus += n * 10; break;
          case "LN" : globalMul += n * 5; break;
          case "MET": hybridAPC += n * 5; hybridAPS += n * 5; break;
          case "NM" : inflRed += n * 5; break;
          case "AE" : frenzyBase += n; break;
        }
      }

      // Sets complets
      const isSet = f => (perFamCount[f]||0) === (FAMILY_SET_SIZES[f]||0);
      if (isSet("ALK")) critUnits += 5;
      if (isSet("HAL")) apcMul = Math.floor(apcMul * 1100 / MULTIPLIER_SCALE);
      if (isSet("NG"))  apsMul = Math.floor(apsMul * 1100 / MULTIPLIER_SCALE);
      if (isSet("C"))  { apcFlat += 5; apsFlat += 5; }
      if (isSet("AN"))  offlineBonus += 500;
      if (isSet("LN"))  globalMul = Math.floor(globalMul * 1100 / MULTIPLIER_SCALE);
      if (isSet("MET")) { hybridAPC += 50; hybridAPS += 50; }
      if (isSet("NM"))  inflRed += 100;
      if (isSet("AE"))  frenzyBase += 10;

      inflRed = Math.min(inflRed, 900);

      const critChance = Math.min(500, critUnits * 10);
      const extraCritUnits = Math.max(0, critUnits - 50);
      const critDamagePercent = 100 + extraCritUnits * 10;

      return { critChance, critDamagePercent, apcMul, apsMul, apcFlat, apsFlat, inflRed, offlineBonus, globalMul, isoDiscount, hybridAPC, hybridAPS, frenzyBase };
    }

    function applyMultiplier(value, multiplier){
      if (value <= 0 || multiplier <= 0) return 0;
      return Math.floor(value * multiplier / MULTIPLIER_SCALE);
    }

    function computeDerivedStats(){
      const { critChance, critDamagePercent, apcMul, apsMul, apcFlat, apsFlat, inflRed, offlineBonus, globalMul, isoDiscount, hybridAPC, hybridAPS, frenzyBase } = computeFamilyEffects();
      currentFrenzyMultiplierBase = Math.max(1, frenzyBase);
      const apcFrenzyMultiplier = Math.max(1, getActiveApcFrenzyMultiplier());
      const apsFrenzyMultiplier = Math.max(1, getActiveApsFrenzyMultiplier());

      const apcBaseValue = Math.max(0, baseApc);
      const apsBaseValue = Math.max(0, baseAps);
      const apcFlatBonus = Math.max(0, apcFlat);
      const apsFlatBonus = Math.max(0, apsFlat);
      const apcFamilyPercent = Math.max(0, apcMul - MULTIPLIER_SCALE);
      const apsFamilyPercent = Math.max(0, apsMul - MULTIPLIER_SCALE);
      const apcFamilyBonusValue = (apcBaseValue > 0 && apcFamilyPercent > 0)
        ? Math.floor(apcBaseValue * apcFamilyPercent / MULTIPLIER_SCALE)
        : 0;
      const apsFamilyBonusValue = (apsBaseValue > 0 && apsFamilyPercent > 0)
        ? Math.floor(apsBaseValue * apsFamilyPercent / MULTIPLIER_SCALE)
        : 0;
      const apcAfterFamily = Math.max(0, apcBaseValue + apcFamilyBonusValue);
      const apsAfterFamily = Math.max(0, apsBaseValue + apsFamilyBonusValue);
      const apcAfterFlat = Math.max(0, apcAfterFamily + apcFlatBonus);
      const apsAfterFlat = Math.max(0, apsAfterFamily + apsFlatBonus);

      const apcFamilyMultiplier = apcBaseValue > 0 ? Math.max(0, apcAfterFamily) / apcBaseValue : 1;
      let APC = apcAfterFlat;
      const apcHybridMultiplier = (MULTIPLIER_SCALE + Math.max(0, hybridAPC)) / MULTIPLIER_SCALE;
      APC = applyMultiplier(APC, MULTIPLIER_SCALE + hybridAPC);
      const apcGlobalMultiplier = Math.max(0, globalMul) / MULTIPLIER_SCALE;
      APC = applyMultiplier(APC, globalMul);
      APC = Math.max(0, APC * apcFrenzyMultiplier);
      const apcBinaryMultiplier = Math.max(1, applyBinaryMultiplier(1, apcMultiLvl));
      APC = applyBinaryMultiplier(APC, apcMultiLvl);

      const apsFamilyMultiplier = apsBaseValue > 0 ? Math.max(0, apsAfterFamily) / apsBaseValue : 1;
      let APS = apsAfterFlat;
      const apsHybridMultiplier = (MULTIPLIER_SCALE + Math.max(0, hybridAPS)) / MULTIPLIER_SCALE;
      APS = applyMultiplier(APS, MULTIPLIER_SCALE + hybridAPS);
      const apsGlobalMultiplier = Math.max(0, globalMul) / MULTIPLIER_SCALE;
      APS = applyMultiplier(APS, globalMul);
      APS = Math.max(0, APS * apsFrenzyMultiplier);
      const apsBinaryMultiplier = Math.max(1, applyBinaryMultiplier(1, apsMultiLvl));
      APS = applyBinaryMultiplier(APS, apsMultiLvl);

      return {
        APC,
        APS,
        critChance,
        critDamagePercent,
        inflRed,
        offlineBonus,
        globalMul,
        isoDiscount,
        apcFlat: apcFlatBonus,
        apsFlat: apsFlatBonus,
        apcFrenzyMultiplier,
        apsFrenzyMultiplier,
        frenzyBase,
        apcBaseValue,
        apsBaseValue,
        apcAfterFamily,
        apcAfterFlat,
        apsAfterFamily,
        apsAfterFlat,
        apcFamilyMultiplier,
        apcHybridMultiplier,
        apcGlobalMultiplier,
        apcBinaryMultiplier,
        apsFamilyMultiplier,
        apsHybridMultiplier,
        apsGlobalMultiplier,
        apsBinaryMultiplier
      };
    }

    function getBonusLines(){
      const { critChance, critDamagePercent, apcMul, apsMul, apcFlat, apsFlat, inflRed, offlineBonus, globalMul, isoDiscount, hybridAPC, hybridAPS, frenzyBase } = computeFamilyEffects();
      const combinedApcMul = Math.floor(apcMul * (MULTIPLIER_SCALE + hybridAPC) / MULTIPLIER_SCALE);
      const combinedApsMul = Math.floor(apsMul * (MULTIPLIER_SCALE + hybridAPS) / MULTIPLIER_SCALE);
      const apcBonus = Math.max(0, combinedApcMul - MULTIPLIER_SCALE);
      const apsBonus = Math.max(0, combinedApsMul - MULTIPLIER_SCALE);
      const globalBonus = Math.max(0, globalMul - MULTIPLIER_SCALE);
      const lines = [];
      if (critChance > 0){
        lines.push(`+${chanceScaledToPercent(critChance)}% chance de coup critique (max 50%)`);
        lines.push(`+${formatNumber(critDamagePercent)}% dégâts critiques`);
      } else if (critDamagePercent > 100){
        lines.push(`+${formatNumber(critDamagePercent)}% dégâts critiques`);
      }
      if (apcFlat > 0) lines.push(`+${formatNumber(apcFlat)} APC (bonus plat)`);
      if (apcBonus > 0) lines.push(`+${scaledToPercent(apcBonus)}% APC (production manuelle)`);
      if (apsFlat > 0) lines.push(`+${formatNumber(apsFlat)} APS (bonus plat)`);
      if (apsBonus > 0) lines.push(`+${scaledToPercent(apsBonus)}% APS (production automatique)`);
      if (globalBonus > 0) lines.push(`+${scaledToPercent(globalBonus)}% multiplicateur global`);
      if (offlineBonus > 0) lines.push(`+${scaledToPercent(offlineBonus)}% APS offline`);
      if (inflRed > 0) lines.push(`-${scaledToPercent(inflRed)}% coût des tirages gacha`);
      if (isoDiscount > 0) lines.push(`-${scaledToPercent(isoDiscount)}% coût en isotopes`);
      const frenzyReady = Math.max(1, frenzyBase);
      if (frenzyReady > 1){
        const extra = frenzyReady - 5;
        const extraText = extra > 0 ? ` (bonus AE +${formatNumber(extra)})` : "";
        lines.push(`Multiplicateur Frénésie : ×${formatNumber(frenzyReady)} APC pendant 30s / APS pendant 60s${extraText}`);
      }
      return lines;
    }

    function getFamilySetStatuses(){
      const counts = {};
      for (const key of Object.keys(FAMILIES)) counts[key] = 0;
      for (const el of ELEMENTS){
        if (!gacha.owned[el.symbol]) continue;
        counts[el.family] = (counts[el.family] || 0) + 1;
      }
      return Object.entries(FAMILIES).map(([key, info])=>{
        const owned = counts[key] || 0;
        const required = FAMILY_SET_SIZES[key] || 0;
        const complete = required > 0 && owned >= required;
        return { key, label: info.label, owned, required, complete };
      });
    }

    function getTrophyStatuses(){
      return AUTO_GACHA_TROPHIES.map(trophy => {
        const unlocked = !!trophies[trophy.key];
        const threshold = Math.max(1, trophy.threshold || 1);
        const progress = Math.min(1, totalAtoms / threshold);
        const currentValue = Math.min(totalAtoms, threshold);
        return {
          key: trophy.key,
          name: trophy.name,
          description: trophy.description,
          unlocked,
          threshold,
          progress,
          currentValue
        };
      });
    }

    function renderTrophySection(){
      const statuses = getTrophyStatuses();
      const unlockedStatuses = statuses.filter(status => status.unlocked);
      if (!unlockedStatuses.length) return "";
      const items = unlockedStatuses.map(status => {
        const progressPercent = Math.min(100, Math.floor(status.progress * 100));
        const currentText = formatNumber(status.currentValue);
        const targetText = formatNumber(status.threshold);
        const stateLabel = status.unlocked ? "Débloqué" : `${progressPercent}%`;
        const itemClass = status.unlocked ? "trophy-unlocked" : "trophy-locked";
        return `<li class="${itemClass}"><div class="trophy-name">${status.name}</div><div class="trophy-desc">${status.description}</div><div class="trophy-progress"><span class="trophy-progress-value">${stateLabel}</span><span class="trophy-progress-target">${currentText} / ${targetText} Atoms</span></div></li>`;
      }).join("");
      return `<div class="bonus-section bonus-section-trophies"><h3 class="bonus-subtitle">Trophées</h3><ul class="trophy-list">${items}</ul></div>`;
    }

    function renderBonusHtml(){
      const lines = getBonusLines();
      const sections = [];
      const trophySection = renderTrophySection();
      if (trophySection) sections.push(trophySection);
      if (lines.length === 0){
        sections.push('<div class="bonus-section"><p>Aucun bonus actif pour le moment.</p></div>');
      } else {
        sections.push(`<div class="bonus-section"><h3 class="bonus-subtitle">Effets actifs</h3><ul>${lines.map(line => `<li>${line}</li>`).join("")}</ul></div>`);
      }

      const setStatuses = getFamilySetStatuses();
      if (setStatuses.length > 0){
        const cards = setStatuses.map(status => {
          const progress = status.required > 0 ? `${status.owned} / ${status.required}` : `${status.owned}`;
          const stateText = status.complete ? "Bonus de set activé" : "Bonus de set inactif";
          const statusClass = status.complete ? "set-status-card set-complete" : "set-status-card set-incomplete";
          return `<div class="${statusClass}"><span class="set-status-name">${status.label}</span><span class="set-status-info"><span class="set-status-progress">${progress}</span><span class="set-status-state">${stateText}</span></span></div>`;
        }).join("");
        sections.push(`<div class="bonus-section bonus-section-sets"><h3 class="bonus-subtitle">Bonus de set</h3><div class="set-status-grid">${cards}</div></div>`);
      }

      return sections.join("");
    }

    function refreshBonusList(){
      if (!bonusList) return;
      bonusList.innerHTML = renderBonusHtml();
    }

    function refreshAwakenHighlights(){
      if (!cellMap.size) return;
      for (const [symbol, cell] of cellMap.entries()){
        if (!cell) continue;
        const owned = !!gacha.owned[symbol];
        const level = getAwakenLevel(symbol);
        const baseCost = getAwakenCost(level);
        const isoAmount = getIsoStock(symbol);
        let canAwaken = false;
        if (owned && baseCost != null && level < AWAKEN_MAX){
          const discounted = getDiscountedAwakenCost(level, currentIsoDiscount);
          canAwaken = discounted != null && isoAmount >= discounted;
        }
        cell.classList.toggle("awaken-ready", !!canAwaken);
      }
    }

    function clampRollDiscount(value){
      if (!Number.isFinite(value)) return 0;
      return Math.max(0, Math.min(Math.floor(value), 900));
    }

    function getDiscountedRollCost(baseCost, discountScaled = 0){
      const base = Math.max(0, Math.floor(baseCost));
      if (base <= 0) return 0;
      const discount = clampRollDiscount(discountScaled);
      const adjusted = MULTIPLIER_SCALE - discount;
      if (adjusted <= 0) return 1;
      return Math.max(1, Math.floor(base * adjusted / MULTIPLIER_SCALE));
    }

    function computeNextRollCost(currentCost){
      if (currentCost >= 10000){
        return currentCost + 100;
      }
      const growth = MULTIPLIER_SCALE + 10;
      return Math.max(1, Math.floor(currentCost * growth / MULTIPLIER_SCALE));
    }

    function computeBulkRollCost(quantity, { baseCost = gacha.rollCost, discount = currentRollDiscount } = {}){
      const qty = Math.max(0, toNonNegativeInt(quantity));
      if (qty <= 0) return 0;
      let total = 0;
      let cost = Math.max(0, toNonNegativeInt(baseCost));
      const discountScaled = clampRollDiscount(discount);
      for (let i = 0; i < qty; i++){
        const stepCost = getDiscountedRollCost(cost, discountScaled);
        if (!Number.isFinite(stepCost) || stepCost >= Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;
        if (total > Number.MAX_SAFE_INTEGER - stepCost) return Number.MAX_SAFE_INTEGER;
        total += stepCost;
        cost = computeNextRollCost(cost);
      }
      return total;
    }

    /* ===================== Grille périodique ===================== */
    function buildPeriodicGrids(){
      if (!gridMain) return;
      gridMain.innerHTML = "";
      cellMap.clear();
      if (gachaInfoPanel) gridMain.appendChild(gachaInfoPanel);
      if (awakenWrapper){
        gridMain.appendChild(awakenWrapper);
        awakenWrapper.classList.add("hidden");
      }
      if (awakenBtn){
        awakenBtn.textContent = "Éveil";
        awakenBtn.disabled = true;
        awakenBtn.removeAttribute("title");
      }
      if (elementName) elementName.textContent = "Clique un élément dans la grille";
      if (elementIsoCount) elementIsoCount.textContent = "—";
      // Périodes 1–7 (hors cases "*")
      for (let period=1; period<=7; period++){
        const row = PERIODS[period];
        for (let c=1; c<=18; c++){
          const sym = row[c-1] || "";
          if (!sym || sym==="*") continue;
          const el = ELEMENTS.find(e=>e.symbol===sym && !e.frow);
          const cell = document.createElement("div");
          const colors = FAMILY_COLORS[el.family] || {};
          cell.className = `cell${gacha.owned[el.symbol] ? ' owned' : ''}`;
          cell.style.gridColumn = c;
          cell.style.gridRow = period;
          if (colors.base) cell.style.setProperty("--bg-base", colors.base);
          if (colors.owned) cell.style.setProperty("--bg-owned", colors.owned);
          cell.dataset.symbol = el.symbol;
          cell.dataset.family = el.family;
          cell.innerHTML = `<div class="Z">${el.Z}</div><div class="sym">${el.symbol}</div>`;
          cell.addEventListener("click", ()=> showElementInfo(el));
          cell.addEventListener("dblclick", event => handleCellDoubleClick(el, event));
          gridMain.appendChild(cell);
          cellMap.set(el.symbol, cell);
        }
      }
      // Lanthanides row (col 4->18)
      const lanRowIndex = 8;
      LANTHANIDES.forEach((sym,i)=>{
        const el = ELEMENTS.find(e=>e.symbol===sym);
        const cell = document.createElement("div");
        const colors = FAMILY_COLORS[el.family] || {};
        cell.className = `cell${gacha.owned[el.symbol] ? ' owned' : ''}`;
        cell.style.gridColumn = (4+i);
        cell.style.gridRow = lanRowIndex;
        if (colors.base) cell.style.setProperty("--bg-base", colors.base);
        if (colors.owned) cell.style.setProperty("--bg-owned", colors.owned);
        cell.dataset.symbol = el.symbol;
        cell.dataset.family = el.family;
        cell.innerHTML = `<div class="Z">${el.Z}</div><div class="sym">${el.symbol}</div>`;
        cell.addEventListener("click", ()=> showElementInfo(el));
        cell.addEventListener("dblclick", event => handleCellDoubleClick(el, event));
        gridMain.appendChild(cell);
        cellMap.set(el.symbol, cell);
      });
      // Actinides row (col 4->18)
      const actRowIndex = 9;
      ACTINIDES.forEach((sym,i)=>{
        const el = ELEMENTS.find(e=>e.symbol===sym);
        const cell = document.createElement("div");
        const colors = FAMILY_COLORS[el.family] || {};
        cell.className = `cell${gacha.owned[el.symbol] ? ' owned' : ''}`;
        cell.style.gridColumn = (4+i);
        cell.style.gridRow = actRowIndex;
        if (colors.base) cell.style.setProperty("--bg-base", colors.base);
        if (colors.owned) cell.style.setProperty("--bg-owned", colors.owned);
        cell.dataset.symbol = el.symbol;
        cell.dataset.family = el.family;
        cell.innerHTML = `<div class="Z">${el.Z}</div><div class="sym">${el.symbol}</div>`;
        cell.addEventListener("click", ()=> showElementInfo(el));
        cell.addEventListener("dblclick", event => handleCellDoubleClick(el, event));
        gridMain.appendChild(cell);
        cellMap.set(el.symbol, cell);
      });
      refreshAwakenHighlights();
    }

    function refreshElementPanel({ forceRecompute = false } = {}){
      if (forceRecompute){
        const derived = computeDerivedStats();
        currentIsoDiscount = derived.isoDiscount || 0;
        currentRollDiscount = clampRollDiscount(derived.inflRed || 0);
      }
      if (!currentElement){
        if (elementName) elementName.textContent = "Clique un élément dans la grille";
        if (elementIsoCount) elementIsoCount.textContent = "—";
        if (elementFamily) elementFamily.textContent = "Famille : —";
        if (awakenWrapper) awakenWrapper.classList.add("hidden");
        if (awakenBtn){
          awakenBtn.textContent = "Éveil";
          awakenBtn.disabled = true;
          awakenBtn.removeAttribute("title");
        }
        return;
      }
      const el = currentElement;
      const owned = !!gacha.owned[el.symbol];
      const isoAmount = getIsoStock(el.symbol);
      const awakenLevel = getAwakenLevel(el.symbol);
      const maxLevel = Math.min(AWAKEN_MAX, AWAKEN_COSTS.length);
      if (elementName) elementName.textContent = `${el.name} (${el.symbol})`;
      if (elementFamily){
        const familyDef = FAMILIES[el.family] || {};
        const familyLabel = familyDef.label || el.family;
        const bonusLabel = familyDef.bonusDesc || "";
        const bonusText = bonusLabel ? ` (Bonus: ${bonusLabel})` : "";
        elementFamily.textContent = `Famille : ${familyLabel}${bonusText}`;
      }
      if (elementIsoCount) elementIsoCount.textContent = formatNumber(isoAmount);
      if (!awakenWrapper || !awakenBtn) return;
      const progressText = `(${awakenLevel}/${maxLevel})`;
      const baseCost = getDiscountedAwakenCost(awakenLevel, currentIsoDiscount);
      const costText = baseCost != null ? `${formatNumber(baseCost)} iso` : "—";
      if (!owned){
        awakenWrapper.classList.remove("hidden");
        awakenBtn.textContent = `Éveil : ${costText} ${progressText}`;
        awakenBtn.disabled = true;
        awakenBtn.title = "Obtiens cet élément pour l'éveiller";
      } else if (awakenLevel >= maxLevel){
        awakenWrapper.classList.remove("hidden");
        awakenBtn.textContent = `Éveil max ${progressText}`;
        awakenBtn.disabled = true;
        awakenBtn.removeAttribute("title");
      } else {
        const discountLabel = currentIsoDiscount > 0 ? ` (-${scaledToPercent(currentIsoDiscount)}%)` : "";
        const isoText = baseCost != null ? `${formatNumber(baseCost)} iso${discountLabel}` : costText;
        awakenWrapper.classList.remove("hidden");
        awakenBtn.textContent = `Éveil : ${isoText} ${progressText}`;
        awakenBtn.disabled = baseCost == null || isoAmount < baseCost;
        if (awakenBtn.disabled && baseCost != null){
          awakenBtn.title = `Requiert ${formatNumber(baseCost)} isotopes`;
        } else {
          awakenBtn.removeAttribute("title");
        }
      }
      if (forceRecompute) refreshAwakenHighlights();
    }

    function showElementInfo(el){
      currentElement = el;
      refreshElementPanel({ forceRecompute: true });
    }

    function handleCellDoubleClick(el, event){
      if (!el) return;
      if (event){
        event.preventDefault();
        event.stopPropagation();
      }
      showElementInfo(el);
      attemptAwaken();
    }

    function attemptAwaken(){
      if (!currentElement) return;
      const el = currentElement;
      if (!gacha.owned[el.symbol]) return;
      const level = getAwakenLevel(el.symbol);
      if (level >= AWAKEN_MAX) return;
      const derived = computeDerivedStats();
      currentIsoDiscount = derived.isoDiscount || 0;
      currentRollDiscount = clampRollDiscount(derived.inflRed || 0);
      const cost = getDiscountedAwakenCost(level, currentIsoDiscount);
      if (cost == null) return;
      if (!spendIsotopes(el.symbol, cost)) return;
      setAwakenLevel(el.symbol, level + 1);
      saveAndUpdate();
      refreshElementPanel();
    }

    /* ===================== Tirage Gacha ===================== */
    function rollGacha({ free = false, displayResult = true } = {}){
      const baseCost = gacha.rollCost;
      const discountScaled = clampRollDiscount(currentRollDiscount);
      const cost = getDiscountedRollCost(baseCost, discountScaled);
      if (!free && atoms < cost) return null;

      if (!free){
        atoms = Math.max(0, atoms - cost);
        gacha.rollCost = computeNextRollCost(baseCost);
      }

      // Choix famille puis élément aléatoire dans cette famille
      const fam = pickFamily();
      const pool = ELEMENTS.filter(e=>e.family===fam);
      if (!pool.length) return null;
      const el = pool[Math.floor(Math.random()*pool.length)];

      gacha.pulls++;
      let first = false;
      let lootRarity = null;
      let isoGain = 0;
      if (gacha.owned[el.symbol]){
        gacha.dupes[el.symbol] = (gacha.dupes[el.symbol]||0) + 1;
        lootRarity = rollLootRarity();
        isoGain = lootRarity.multiplier;
        addIsotopes(el.symbol, isoGain);
      } else {
        gacha.owned[el.symbol] = 1;
        first = true;
      }

      // Feedback UI : encart loot + mise à jour grille
      if (displayResult){
        if (lastLootBox) lastLootBox.classList.remove("hidden");
        if (lastLootName) lastLootName.textContent = `${el.name} (${el.symbol})`;
        if (lastLootFam) lastLootFam.textContent = `${FAMILIES[fam]?.label || fam}`;
        if (first){
          setLootResultClass("is-new");
          if (lastLootType) lastLootType.textContent = "Nouveau!";
        } else if (lootRarity){
          setLootResultClass(`rarity-${lootRarity.key}`);
          if (lastLootType) lastLootType.textContent = `Doublons x${lootRarity.multiplier}`;
        } else {
          setLootResultClass(null);
          if (lastLootType) lastLootType.textContent = "—";
        }
      }

      // Surbrillance de la case
      [...document.querySelectorAll('[data-symbol]')].forEach(n=>{
        if (n.dataset.symbol===el.symbol) n.classList.add('owned');
      });

      return { element: el, family: fam, isNew: first, lootRarity, isoGain };
    }

    /* ===================== Interactions & Boucles ===================== */
    function prepareResetModal(){
      if (!resetWordEl) return;
      const word = RESET_WORDS[Math.floor(Math.random() * RESET_WORDS.length)] || "reset";
      currentResetWord = word;
      resetWordEl.textContent = word;
      if (resetInput) resetInput.value = "";
      if (resetConfirmBtn) resetConfirmBtn.disabled = true;
      if (typeof updateResetConfirmState === "function") updateResetConfirmState();
      setTimeout(()=>{ if (resetInput) resetInput.focus(); }, 50);
    }

    function openResetModal(){
      if (!resetModal) return;
      prepareResetModal();
      resetModal.classList.remove("hidden");
    }

    function closeResetModal(){
      if (!resetModal) return;
      resetModal.classList.add("hidden");
      currentResetWord = "";
      if (resetInput) resetInput.value = "";
      if (resetConfirmBtn) resetConfirmBtn.disabled = true;
    }

    function performRevive(){
      const tier = getReviveTier(reviveCount);
      if (!tier) return false;
      const cost = tier.cost;
      if (!Number.isFinite(cost) || cost <= 0) return false;
      if (atoms < cost) return false;
      atoms = Math.max(0, atoms - cost);
      reviveCount += 1;
      reviveUnlocked = true;
      const baseValues = getReviveBaseStartValue(reviveCount);
      baseApc = baseValues.apc;
      baseAps = baseValues.aps;
      apcLvl = 0;
      autoLvl = 0;
      apcMultiLvl = 0;
      apsMultiLvl = 0;
      trophies = {};
      const now = Date.now();
      last = now;
      sessionStartTime = now;
      sessionManualClicks = 0;
      sessionAtomsBaseline = totalAtoms;
      reviveRunAtoms = 0;
      reviveRunClicks = 0;
      currentElement = null;
      currentIsoDiscount = 0;
      currentRollDiscount = 0;
      apcFrenzyEffects = [];
      apsFrenzyEffects = [];
      currentFrenzyMultiplierBase = 5;
      hideApcFrenzyOrb();
      hideApsFrenzyOrb();
      resetAutoGachaCooldown();
      lastAutoResult = null;
      updateAutoGachaHeader();
      gacha = createDefaultGachaState();
      syncTotalIsotopes();
      if (autoGachaPanel) autoGachaPanel.classList.add("hidden");
      if (lastLootBox) lastLootBox.classList.add("hidden");
      if (lastLootName) lastLootName.textContent = "—";
      if (lastLootFam) lastLootFam.textContent = "—";
      setLootResultClass(null);
      if (lastLootType) lastLootType.textContent = "—";
      atoms = 0;
      buildPeriodicGrids();
      updateReviveNavState();
      saveAll();
      updateUI();
      return true;
    }

    function performReset(){
      atoms = 0;
      reviveCount = 0;
      reviveRunAtoms = 0;
      reviveRunClicks = 0;
      reviveUnlocked = false;
      const baseValues = getReviveBaseStartValue(0);
      baseApc = baseValues.apc;
      baseAps = baseValues.aps;
      apcLvl = 0;
      autoLvl = 0;
      apcMultiLvl = 0;
      apsMultiLvl = 0;
      totalAtoms = 0;
      trophies = {};
      last = Date.now();
      manualClicksTotal = 0;
      sessionManualClicks = 0;
      sessionAtomsBaseline = totalAtoms;
      sessionStartTime = Date.now();
      gameStart = sessionStartTime;
      gacha = createDefaultGachaState();
      syncTotalIsotopes();
      currentElement = null;
      currentIsoDiscount = 0;
      currentRollDiscount = 0;
      apcFrenzyEffects = [];
      apsFrenzyEffects = [];
      currentFrenzyMultiplierBase = 5;
      hideApcFrenzyOrb();
      hideApsFrenzyOrb();
      resetAutoGachaCooldown();
      lastAutoResult = null;
      updateAutoGachaHeader();
      if (autoGachaPanel) autoGachaPanel.classList.add("hidden");
      if (lastLootBox) lastLootBox.classList.add("hidden");
      if (lastLootName) lastLootName.textContent = "—";
      if (lastLootFam) lastLootFam.textContent = "—";
      setLootResultClass(null);
      if (lastLootType) lastLootType.textContent = "—";
      localStorage.removeItem("miniAtomState");
      localStorage.removeItem("gacha");
      buildPeriodicGrids();
      updateReviveNavState();
      saveAll();
      updateUI();
    }

    // Clic partout sur la page principale
    if (mainPageEl){
      mainPageEl.addEventListener("click", ()=>{
        manualClicksTotal += 1;
        sessionManualClicks += 1;
        reviveRunClicks += 1;
        const { APC, critChance, critDamagePercent } = computeDerivedStats();
        let gain = Math.max(0, toNonNegativeInt(APC));
        let isCrit = false;
        if (critChance > 0){
          const roll = Math.floor(Math.random() * CHANCE_SCALE);
          isCrit = roll < critChance;
          if (isCrit){
            gain = Math.max(gain, Math.floor(gain * critDamagePercent / 100));
          }
        }
        addAtoms(gain);
        animateAtom(isCrit);
        updateUI();
      });
    }

    if (apcFrenzyOrbEl){
      apcFrenzyOrbEl.addEventListener("click", event=>{
        event.preventDefault();
        event.stopPropagation();
        playPopSound();
        hideApcFrenzyOrb();
        triggerApcFrenzyBonus();
      });
    }

    if (apsFrenzyOrbEl){
      apsFrenzyOrbEl.addEventListener("click", event=>{
        event.preventDefault();
        event.stopPropagation();
        playPopSound();
        hideApsFrenzyOrb();
        triggerApsFrenzyBonus();
      });
    }

    if (awakenBtn){
      awakenBtn.addEventListener("click", attemptAwaken);
    }

    // Améliorations de base
    const baseApcCost = 15;
    const baseAutoCost = 50;
    const UPGRADE_STAGE_SIZE = 100;

    function computeUpgradeCost(baseCost, level, baseIncrement){
      const base = Math.max(1, baseCost);
      const increment = Math.max(0, toNonNegativeInt(baseIncrement ?? base));
      const lvl = Math.max(0, toNonNegativeInt(level));
      if (lvl <= 0) return base;

      let totalIncrease = 0;
      let step = increment;

      for (let stage = 0; ; stage++){
        const stageStart = stage === 0 ? 0 : stage * UPGRADE_STAGE_SIZE - 1;
        if (stageStart >= lvl) break;
        if (stage > 0){
          if (!Number.isFinite(step) || step > Number.MAX_SAFE_INTEGER / 2){
            return Number.MAX_SAFE_INTEGER;
          }
          step *= 2;
        }
        const stageEnd = (stage + 1) * UPGRADE_STAGE_SIZE - 2;
        const effectiveEnd = Math.min(lvl - 1, stageEnd);
        if (effectiveEnd < stageStart) continue;
        const count = effectiveEnd - stageStart + 1;
        if (!Number.isFinite(step) || step > Number.MAX_SAFE_INTEGER / Math.max(1, count)){
          return Number.MAX_SAFE_INTEGER;
        }
        const stageIncrease = step * count;
        if (!Number.isFinite(stageIncrease) || stageIncrease > Number.MAX_SAFE_INTEGER - totalIncrease){
          return Number.MAX_SAFE_INTEGER;
        }
        totalIncrease += stageIncrease;
      }

      const total = base + totalIncrease;
      if (!Number.isFinite(total) || total > Number.MAX_SAFE_INTEGER){
        return Number.MAX_SAFE_INTEGER;
      }
      return Math.max(1, Math.floor(total));
    }

    const apcCost = lvl => computeUpgradeCost(baseApcCost, lvl, baseApcCost);
    const autoCost = lvl => computeUpgradeCost(baseAutoCost, lvl, baseAutoCost);

    function computeBulkUpgradeCost(costFn, startLevel, quantity){
      if (typeof costFn !== "function") return Number.MAX_SAFE_INTEGER;
      const qty = Math.max(0, toNonNegativeInt(quantity));
      if (qty <= 0) return 0;
      let total = 0;
      let level = Math.max(0, toNonNegativeInt(startLevel));
      for (let i = 0; i < qty; i++){
        const stepCost = toNonNegativeInt(costFn(level));
        if (!Number.isFinite(stepCost) || stepCost >= Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;
        if (total > Number.MAX_SAFE_INTEGER - stepCost) return Number.MAX_SAFE_INTEGER;
        total += stepCost;
        level++;
      }
      return total;
    }

    const MULTIPLIER_BASE_COST = 1_000_000;

    function computeMultiplierCost(level){
      const lvl = Math.max(0, toNonNegativeInt(level));
      let cost = MULTIPLIER_BASE_COST;
      for (let i = 0; i < lvl; i++){
        if (!Number.isFinite(cost) || cost > Number.MAX_SAFE_INTEGER / 10){
          return Number.MAX_SAFE_INTEGER;
        }
        cost *= 10;
      }
      if (!Number.isFinite(cost)) return Number.MAX_SAFE_INTEGER;
      return Math.max(1, Math.floor(cost));
    }

    function applyBinaryMultiplier(value, level){
      const baseValue = Math.max(0, toNonNegativeInt(value));
      if (baseValue <= 0) return 0;
      const lvl = Math.max(0, toNonNegativeInt(level));
      if (lvl <= 0) return baseValue;
      const multiplier = Math.pow(2, lvl);
      if (!Number.isFinite(multiplier) || multiplier > Number.MAX_SAFE_INTEGER){
        return Number.MAX_SAFE_INTEGER;
      }
      const result = baseValue * multiplier;
      if (!Number.isFinite(result) || result > Number.MAX_SAFE_INTEGER){
        return Number.MAX_SAFE_INTEGER;
      }
      return Math.max(0, Math.floor(result));
    }

    function attemptFlatUpgrade(type, quantity){
      const qty = Math.max(0, toNonNegativeInt(quantity));
      if (qty <= 0) return false;
      const costFn = type === "apc" ? apcCost : autoCost;
      const currentLevel = type === "apc" ? apcLvl : autoLvl;
      const totalCost = computeBulkUpgradeCost(costFn, currentLevel, qty);
      if (!Number.isFinite(totalCost) || totalCost <= 0) return false;
      if (atoms < totalCost) return false;
      const increment = Math.max(0, toNonNegativeInt(getReviveShopIncrementValue()));
      if (increment <= 0) return false;
      const totalIncrement = increment * qty;
      if (!Number.isFinite(totalIncrement)) return false;
      if (type === "apc"){
        const newBase = baseApc + totalIncrement;
        if (!Number.isFinite(newBase)) return false;
        atoms = Math.max(0, atoms - totalCost);
        baseApc = newBase;
        apcLvl += qty;
      } else {
        const newBase = baseAps + totalIncrement;
        if (!Number.isFinite(newBase)) return false;
        atoms = Math.max(0, atoms - totalCost);
        baseAps = newBase;
        autoLvl += qty;
      }
      saveAndUpdate();
      return true;
    }

    if (btnBuyApc) btnBuyApc.addEventListener("click", ()=>{ attemptFlatUpgrade("apc", 1); });
    if (btnBuyApc10) btnBuyApc10.addEventListener("click", ()=>{ attemptFlatUpgrade("apc", 10); });
    if (btnBuyApc100) btnBuyApc100.addEventListener("click", ()=>{ attemptFlatUpgrade("apc", 100); });
    if (btnBuyAuto) btnBuyAuto.addEventListener("click", ()=>{ attemptFlatUpgrade("aps", 1); });
    if (btnBuyAuto10) btnBuyAuto10.addEventListener("click", ()=>{ attemptFlatUpgrade("aps", 10); });
    if (btnBuyAuto100) btnBuyAuto100.addEventListener("click", ()=>{ attemptFlatUpgrade("aps", 100); });
    if (btnBuyApcMulti) btnBuyApcMulti.addEventListener("click", ()=>{
      const cost = computeMultiplierCost(apcMultiLvl);
      if (atoms >= cost){
        atoms -= cost; apcMultiLvl++; saveAndUpdate();
      }
    });
    if (btnBuyApsMulti) btnBuyApsMulti.addEventListener("click", ()=>{
      const cost = computeMultiplierCost(apsMultiLvl);
      if (atoms >= cost){
        atoms -= cost; apsMultiLvl++; saveAndUpdate();
      }
    });

    if (reviveBuyBtn){
      reviveBuyBtn.addEventListener("click", ()=>{
        performRevive();
      });
    }

    function performBulkRoll(quantity){
      const qty = Math.max(0, toNonNegativeInt(quantity));
      if (qty <= 0) return false;
      const totalCost = computeBulkRollCost(qty, { baseCost: gacha.rollCost, discount: currentRollDiscount });
      if (!Number.isFinite(totalCost) || atoms < totalCost) return false;
      let success = false;
      for (let i = 0; i < qty; i++){
        const result = rollGacha({ displayResult:false });
        if (!result) break;
        success = true;
      }
      if (success) saveAndUpdate();
      return success;
    }

    // Tirage
    if (rollBtn) rollBtn.addEventListener("click", ()=>{
      const result = rollGacha();
      if (result) saveAndUpdate();
    });
    if (roll10Btn) roll10Btn.addEventListener("click", ()=>{
      performBulkRoll(10);
    });
    if (roll100Btn) roll100Btn.addEventListener("click", ()=>{
      performBulkRoll(100);
    });

    // Navigation
    const pageElements = new Map([
      ["mainPage", mainPageEl],
      ["shopPage", shopPageEl],
      ["gachaPage", gachaPageEl],
      ["bonusPage", bonusPageEl],
      ["infosPage", infosPageEl],
      ["revivePage", revivePageEl],
      ["optionsPage", optionsPageEl]
    ]);

    /**
     * Active la page demandée et synchronise l'état du menu.
     * Cette fonction centralise toute la logique de navigation pour
     * éviter les oublis lors de l'ajout de nouvelles pages.
     */
    function activatePage(pageId){
      if (pageId === "revivePage" && !reviveUnlocked){
        pageId = "mainPage";
      }
      if (!pageElements.has(pageId)) return;
      pageElements.forEach((pageEl, id)=>{
        if (!pageEl) return;
        if (id === pageId){
          pageEl.classList.add("active");
        } else {
          pageEl.classList.remove("active");
        }
      });
      navButtons.forEach(btn=>{
        const target = btn.dataset.pageTarget;
        const isActive = target === pageId;
        btn.classList.toggle("active", isActive);
        if (isActive){
          btn.setAttribute("aria-current", "page");
        } else {
          btn.removeAttribute("aria-current");
        }
      });
      if (pageId !== "mainPage"){
        hideApcFrenzyOrb();
        hideApsFrenzyOrb();
      }
      updateUI();
    }

    navButtons.forEach(btn=>{
      btn.addEventListener("click", ()=>{
        if (btn.disabled) return;
        const target = btn.dataset.pageTarget;
        if (target === "revivePage" && !reviveUnlocked) return;
        if (target) activatePage(target);
      });
    });

    // Thèmes
    themeButtons.forEach(btn=>{
      btn.addEventListener("click", ()=>{
        applyTheme(btn.dataset.theme);
      });
    });

    function updateResetConfirmState(){
      if (!resetConfirmBtn) return;
      const inputValue = resetInput ? resetInput.value : "";
      const matches = normalizeWord(inputValue) === normalizeWord(currentResetWord);
      resetConfirmBtn.disabled = !matches;
    }

    if (resetBtn){
      resetBtn.addEventListener("click", openResetModal);
    }
    if (resetInput){
      resetInput.addEventListener("input", updateResetConfirmState);
      resetInput.addEventListener("keydown", event=>{
        if (event.key === "Enter" && resetConfirmBtn && !resetConfirmBtn.disabled){
          event.preventDefault();
          if (normalizeWord(resetInput.value) === normalizeWord(currentResetWord)){
            performReset();
            closeResetModal();
          }
        }
      });
    }
    if (resetConfirmBtn){
      resetConfirmBtn.addEventListener("click", ()=>{
        const inputValue = resetInput ? resetInput.value : "";
        if (normalizeWord(inputValue) === normalizeWord(currentResetWord)){
          performReset();
          closeResetModal();
        }
      });
    }
    if (resetCancelBtn){
      resetCancelBtn.addEventListener("click", closeResetModal);
    }
    if (resetCloseBtn){
      resetCloseBtn.addEventListener("click", closeResetModal);
    }
    if (resetModal){
      resetModal.addEventListener("click", event=>{
        if (event.target === resetModal) closeResetModal();
      });
    }

    document.addEventListener("keydown", event=>{
      if (event.key === "Escape"){
        if (resetModal && !resetModal.classList.contains("hidden")) closeResetModal();
      }
    });

    // Offline progress (avec bonus offline via Actinides)
    (function applyOfflineProgress(){
      if (!last) return;
      const elapsedMs = Math.max(0, Date.now() - last);
      const elapsed = Math.floor(elapsedMs / 1000);
      if (elapsed <= 0) return;
      const { APS, offlineBonus } = computeDerivedStats();
      if (APS > 0){
        const apsInt = toNonNegativeInt(APS);
        const bonus = Math.max(0, Math.min(offlineBonus, MULTIPLIER_SCALE));
        const gain = Math.floor(apsInt * elapsed * (MULTIPLIER_SCALE + bonus) / MULTIPLIER_SCALE);
        addAtoms(gain, { silent:true });
      }
    })();

    // Boucle d’auto-gain
    setInterval(()=>{
      const { APS } = computeDerivedStats();
      addAtoms(toNonNegativeInt(APS), { silent:true });
    }, 1000);

    setInterval(()=> handleAutoGachaTick(1), 1000);

    // Apparition du bonus Frénésie
    setInterval(()=>{
      checkApcFrenzySpawn();
      checkApsFrenzySpawn();
    }, 1000);

    // Rendu + autosave
    setInterval(()=>{ saveAll(); updateUI(); }, 1000);

    function updateReviveNavState(){
      if (reviveNavButton){
        reviveNavButton.disabled = !reviveUnlocked;
      }
    }

    function updateReviveUI(){
      const baseBonus = getReviveTotalBonus(reviveCount);
      if (reviveCountStatEl) reviveCountStatEl.textContent = formatNumber(reviveCount);
      if (reviveBaseStatEl){
        const bonusText = reviveCount > 0 ? `+${formatNumber(baseBonus)}` : "+0";
        reviveBaseStatEl.textContent = bonusText;
      }
      const shopIncrement = getReviveShopIncrementValue();
      if (reviveShopStatEl) reviveShopStatEl.textContent = `+${formatNumber(shopIncrement)} / achat`;
      const accessible = reviveUnlocked;
      if (reviveOfferEl) reviveOfferEl.classList.toggle("hidden", !accessible);
      if (reviveLockedMessageEl){
        if (!accessible){
          const unlockCostText = formatNumber(getReviveCostValue(0));
          reviveLockedMessageEl.textContent = `Atteins ${unlockCostText} Atoms simultanément pour débloquer la renaissance.`;
          reviveLockedMessageEl.classList.remove("hidden");
        } else {
          reviveLockedMessageEl.classList.add("hidden");
        }
      }
      if (!reviveBuyBtn) return;
      const tier = getReviveTier(reviveCount);
      const hasTier = accessible && tier && Number.isFinite(tier.cost) && tier.cost > 0 && tier.cost < Number.MAX_VALUE;
      if (reviveCostValueEl){
        if (hasTier){
          reviveCostValueEl.textContent = `${formatNumber(tier.cost)} Atoms`;
        } else {
          reviveCostValueEl.textContent = "—";
        }
      }
      if (reviveRewardValueEl){
        if (hasTier){
          reviveRewardValueEl.textContent = `+${formatNumber(tier.reward)} APC / APS`;
        } else if (!accessible){
          reviveRewardValueEl.textContent = "+0 APC / APS";
        } else {
          reviveRewardValueEl.textContent = "Bonus maximal atteint";
        }
      }
      if (!accessible){
        reviveBuyBtn.disabled = true;
        return;
      }
      if (!hasTier){
        reviveBuyBtn.disabled = true;
        reviveBuyBtn.textContent = "Renaissance maximale";
        return;
      }
      const costText = formatNumber(tier.cost);
      const canAfford = atoms >= tier.cost;
      reviveBuyBtn.disabled = !canAfford;
      reviveBuyBtn.textContent = canAfford ? `Déclencher (${costText})` : `Coût : ${costText}`;
    }

    function updateUI(){
      const derived = computeDerivedStats();
      const { APC, APS, isoDiscount = 0, inflRed = 0, apcFrenzyMultiplier = 1, apsFrenzyMultiplier = 1, frenzyBase = currentFrenzyMultiplierBase } = derived;
      currentIsoDiscount = isoDiscount;
      currentRollDiscount = clampRollDiscount(inflRed);
      updateAutoGachaHeader();
      updateReviveNavState();

      const atomsText = formatNumber(atoms);
      const apsText = formatNumber(APS);
      const apcText = formatNumber(APC);

      if (elAtoms) elAtoms.textContent = atomsText;
      elAps.textContent = apsText;
      elApc.textContent = apcText;

      elAtomsShop.textContent = atomsText;
      elApsShop.textContent = apsText;
      elApcShop.textContent = apcText;

      if (elAtomsGacha) elAtomsGacha.textContent = atomsText;
      if (elApsGacha) elApsGacha.textContent = apsText;
      if (elApcGacha) elApcGacha.textContent = apcText;

      if (apcFrenzyStatusEl){
        const stacks = getApcFrenzyStackCount();
        if (stacks > 0){
          const remainingMs = getLongestApcFrenzyRemaining();
          const remainingSec = Math.max(0, Math.ceil(remainingMs / 1000));
          apcFrenzyStatusEl.textContent = `×${formatNumber(apcFrenzyMultiplier)} – ${remainingSec}s`;
          apcFrenzyStatusEl.classList.add("active");
        } else {
          apcFrenzyStatusEl.textContent = "";
          apcFrenzyStatusEl.classList.remove("active");
        }
      }

      if (apsFrenzyStatusEl){
        const stacks = getApsFrenzyStackCount();
        if (stacks > 0){
          const remainingMs = getLongestApsFrenzyRemaining();
          const remainingSec = Math.max(0, Math.ceil(remainingMs / 1000));
          apsFrenzyStatusEl.textContent = `×${formatNumber(apsFrenzyMultiplier)} – ${remainingSec}s`;
          apsFrenzyStatusEl.classList.add("active");
        } else {
          apsFrenzyStatusEl.textContent = "";
          apsFrenzyStatusEl.classList.remove("active");
        }
      }

      if (totalAtoms < sessionAtomsBaseline) sessionAtomsBaseline = totalAtoms;
      const now = Date.now();
      if (infosSessionAtomsEl){
        const sessionGain = Math.max(0, totalAtoms - sessionAtomsBaseline);
        infosSessionAtomsEl.textContent = formatNumber(sessionGain);
      }
      if (infosSessionClicksEl) infosSessionClicksEl.textContent = formatNumber(sessionManualClicks);
      if (infosSessionDurationEl) infosSessionDurationEl.textContent = formatSessionDuration(now - sessionStartTime);
      if (infosReviveAtomsEl) infosReviveAtomsEl.textContent = formatNumber(reviveRunAtoms);
      if (infosLifetimeAtomsEl) infosLifetimeAtomsEl.textContent = formatNumber(totalAtoms);
      if (infosReviveClicksEl) infosReviveClicksEl.textContent = formatNumber(reviveRunClicks);
      if (infosLifetimeClicksEl) infosLifetimeClicksEl.textContent = formatNumber(manualClicksTotal);
      if (infosReviveCountEl) infosReviveCountEl.textContent = formatNumber(reviveCount);
      if (infosTotalRuntimeEl) infosTotalRuntimeEl.textContent = formatRuntimeDuration(Math.max(0, now - gameStart));

      if (infosApcBaseEl) infosApcBaseEl.textContent = formatNumber(derived.apcBaseValue);
      if (infosApcFlatEl) infosApcFlatEl.textContent = formatNumber(derived.apcFlat);
      if (infosApcAfterFlatEl) infosApcAfterFlatEl.textContent = formatNumber(derived.apcAfterFlat);
      if (infosApcTotalEl) infosApcTotalEl.textContent = apcText;
      renderMultiplierList(infosApcMultipliersEl, [
        { label: 'Bonus APC', value: derived.apcFamilyMultiplier },
        { label: 'Bonus métalloïdes', value: derived.apcHybridMultiplier },
        { label: 'Multiplicateur global', value: derived.apcGlobalMultiplier },
        { label: 'Frénésie APC', value: derived.apcFrenzyMultiplier },
        { label: 'Multiplicateur APC ×2', value: derived.apcBinaryMultiplier }
      ]);

      if (infosApsBaseEl) infosApsBaseEl.textContent = formatNumber(derived.apsBaseValue);
      if (infosApsFlatEl) infosApsFlatEl.textContent = formatNumber(derived.apsFlat);
      if (infosApsAfterFlatEl) infosApsAfterFlatEl.textContent = formatNumber(derived.apsAfterFlat);
      if (infosApsTotalEl) infosApsTotalEl.textContent = apsText;
      renderMultiplierList(infosApsMultipliersEl, [
        { label: 'Bonus APS', value: derived.apsFamilyMultiplier },
        { label: 'Bonus métalloïdes', value: derived.apsHybridMultiplier },
        { label: 'Multiplicateur global', value: derived.apsGlobalMultiplier },
        { label: 'Frénésie APS', value: derived.apsFrenzyMultiplier },
        { label: 'Multiplicateur APS ×2', value: derived.apsBinaryMultiplier }
      ]);

      // Boutons de base
      const shopIncrement = getReviveShopIncrementValue();
      const shopIncrementText = formatNumber(shopIncrement);
      const apcSingleCost = apcCost(apcLvl);
      const autoSingleCost = autoCost(autoLvl);
      const apcBulk10Cost = computeBulkUpgradeCost(apcCost, apcLvl, 10);
      const apcBulk100Cost = computeBulkUpgradeCost(apcCost, apcLvl, 100);
      const autoBulk10Cost = computeBulkUpgradeCost(autoCost, autoLvl, 10);
      const autoBulk100Cost = computeBulkUpgradeCost(autoCost, autoLvl, 100);
      const apcMultiCost = computeMultiplierCost(apcMultiLvl);
      const apsMultiCost = computeMultiplierCost(apsMultiLvl);

      const apcInc10 = shopIncrement * 10;
      const apcInc100 = shopIncrement * 100;
      const autoInc10 = shopIncrement * 10;
      const autoInc100 = shopIncrement * 100;

      const formatAtomsCost = value => `${formatNumber(value)} Atoms`;
      const applyShopState = (button, cost, label) => {
        if (!button) return;
        const priceEl = button.querySelector('.option-price');
        if (priceEl) priceEl.textContent = formatAtomsCost(cost);
        if (label) button.setAttribute('aria-label', label);
        const unavailable = atoms < cost;
        button.classList.toggle('not-available', unavailable);
        if (unavailable) {
          button.setAttribute('aria-disabled', 'true');
        } else {
          button.removeAttribute('aria-disabled');
        }
      };

      applyShopState(btnBuyApc, apcSingleCost, `Acheter APC ×1 (+${shopIncrementText}) pour ${formatAtomsCost(apcSingleCost)}`);
      applyShopState(btnBuyApc10, apcBulk10Cost, `Acheter APC ×10 (+${formatNumber(apcInc10)}) pour ${formatAtomsCost(apcBulk10Cost)}`);
      applyShopState(btnBuyApc100, apcBulk100Cost, `Acheter APC ×100 (+${formatNumber(apcInc100)}) pour ${formatAtomsCost(apcBulk100Cost)}`);
      if (infoApc) infoApc.textContent = `Niveau ${apcLvl} – +${shopIncrementText} APC / achat`;

      applyShopState(btnBuyAuto, autoSingleCost, `Acheter Auto ×1 (+${shopIncrementText} APS) pour ${formatAtomsCost(autoSingleCost)}`);
      applyShopState(btnBuyAuto10, autoBulk10Cost, `Acheter Auto ×10 (+${formatNumber(autoInc10)} APS) pour ${formatAtomsCost(autoBulk10Cost)}`);
      applyShopState(btnBuyAuto100, autoBulk100Cost, `Acheter Auto ×100 (+${formatNumber(autoInc100)} APS) pour ${formatAtomsCost(autoBulk100Cost)}`);
      if (infoAuto) infoAuto.textContent = `Niveau ${autoLvl} – +${shopIncrementText} APS / achat`;

      applyShopState(btnBuyApcMulti, apcMultiCost, `Acheter multiplicateur APC pour ${formatAtomsCost(apcMultiCost)}`);
      const apcMultiTotal = applyBinaryMultiplier(1, apcMultiLvl);
      infoApcMulti.textContent = `Achats ${apcMultiLvl} (×${formatNumber(apcMultiTotal)})`;

      applyShopState(btnBuyApsMulti, apsMultiCost, `Acheter multiplicateur APS pour ${formatAtomsCost(apsMultiCost)}`);
      const apsMultiTotal = applyBinaryMultiplier(1, apsMultiLvl);
      infoApsMulti.textContent = `Achats ${apsMultiLvl} (×${formatNumber(apsMultiTotal)})`;

      // Gacha infos
      const displayedRollCost = getDiscountedRollCost(gacha.rollCost, currentRollDiscount);
      applyShopState(rollBtn, displayedRollCost, `Tirage gacha ×1 pour ${formatAtomsCost(displayedRollCost)}`);
      if (rollCostOnBtn) rollCostOnBtn.textContent = formatAtomsCost(displayedRollCost);
      if (roll10CostOnBtn){
        const bulk10Cost = computeBulkRollCost(10, { baseCost: gacha.rollCost, discount: currentRollDiscount });
        applyShopState(roll10Btn, bulk10Cost, `Tirage gacha ×10 pour ${formatAtomsCost(bulk10Cost)}`);
        roll10CostOnBtn.textContent = formatAtomsCost(bulk10Cost);
      }
      if (roll100CostOnBtn){
        const bulk100Cost = computeBulkRollCost(100, { baseCost: gacha.rollCost, discount: currentRollDiscount });
        applyShopState(roll100Btn, bulk100Cost, `Tirage gacha ×100 pour ${formatAtomsCost(bulk100Cost)}`);
        roll100CostOnBtn.textContent = formatAtomsCost(bulk100Cost);
      }
      if (isotopesEl) isotopesEl.textContent = formatNumber(gacha.isotopes);

      refreshBonusList();
      refreshAwakenHighlights();
      updateReviveUI();
      refreshElementPanel();
      updateAutoGachaPanel();
    }

    // Init
    checkTrophies({ silent:true });
    resetAutoGachaCooldown();
    updateAutoGachaHeader();
    updateAutoGachaPanel();
    buildPeriodicGrids();
    updateReviveNavState();
    updateReviveUI();
    activatePage("mainPage");
  </script>
</body>
</html>
